# 12장 함수

## 12-1. 함수란? 
- 함수: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 **정의**한 것
- 매개변수 : 입력을 전달 받는 변수
- 인자 : 입력값
- 반환값 : 출력값
- 함수는 함수 정의를 통해 생성한다. 정의한다고 해서 실행되는 것은 아니다.
- 함수 호출 : 인수를 매개변수를 통해 전달하면서 실행을 명시적으로 지시하는 것

## 12-2. 함수를 사용하는 이유
1. 코드의 재사용성이 높아진다.
2. 유지보수의 편의성이 높아진다.
3. 코드의 신뢰성을 높인다.
4. 코드의 가독성을 향상시킨다.

## 12-3. 함수 리터럴
- 리터럴을 값을 생성하기 위한 표기법니다. 함수 리터럴은 객체 값을 생성하며, 곧 함수는 객체이다.
- 함수 객체는 일반 객체와 다르게 호출할 수 있다.
- 함수 리터럴의 구성요소
  - function 키워드
  - 함수 이름 : 생략가능하며, 이름이 없는 함수는 익명함수라 한다.
  - 매개변수 목록 : 지정한 인수가 순서대로 할당되며, 식별자 네이밍 규칙을 준수해야한다. 
  - 함수 몸체 : 함수가 호출되었을 대 실행되는 코드 불록

## 12-4. 함수 정의

### 12.4.1 함수 선언문
- 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다. 
- 기명 함수 리터럴은 문맥에 따라 함수 선언문으로 해석되기도, 함수 리터럴 표현식으로 해석되기도 한다. 
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수이름과 동일한 식별자를 임의로 생성하고, 거기에 함수 객체를 할당한다. 

```javascript
const add = function add(x, y) {
  return x + y;
}

add(1,2); // 3
```
> **새로 알게된 부분**
> <br/> 함수이름으로 호출하는 것이 아니라 자바스크립트가 임의로 생성한 식별자로 호출한다는 점

### 12.4.2 함수 표현식
- 일급 객체 : 값의 성질을 갖는 객체
- 자바스크립트의 함수는 일급 객체이다. 그러므로 함수를 값처럼 자유롭게 사용할 수 있다.
- 함수 리터럴의 함수 이름은 생략될 수 있으며, 함수 표현식에서의 함수 이름은 생략하는 것이 일반적이다.
- 함수 표현식은 표현식인 문이다.

### 12.4.3 함수 생성시점과 호이스팅
- 함수 선언문으로 생성한 함수는 선언 이전에 호출할 수 있다.
- 함수 표현식으로 정의한 함수는 선언 이전에 호출할 수 없다.
- 함수 호이스팅 : 함수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 동작
  - 변수 호이스팅과 다르게(undefined로 평가) 함수 호이스팅은 선언문 이전에 호출해도 가능하다.
- 함수 표현식으로 정의하면, 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

### 12.4.4 Function 생성자 함수
```javascript
let func = new Function ([arg1, arg2, ...argN], functionBody);
```

- Function 생성자 함수를 통해 함수를 정의하는 방법이며, new 키워드 없이도 생성이 가능하다.
- 선언문이나 표현식으로 생성한 함수와는 다르게 동작하며, 클로져를 생성하지 않는다.

### 12.4.5 화살표 함수
- ES6에서 도입이 되었다.
- 항상 익명함수로 정의한다.
- 기존 함수 선언문이나 함수 표현식과는 다르다.
  - 1. 생성자 함수로 사용할 수 없다.
  - 2. this 바인딩 방식이 다르다.
  - 3. prototype 프로퍼티가 없다.
  - 4. arguments 객체를 생성하지 않는다.

## 12-5. 함수 호출

### 12.5.1 매개변수와 인수
- 함수를 실행하기 위해 외부에서 필요한 값을 전달해야할 경우 매개변수를 통해 인수를 전달한다.
- 인수는 값으로 평가될 수 있는 표현식이어야 한다. 개수와 타입에는 제한이 없다.
- 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다.
- 매개변수의 스코프는 함수 내부이다.
- 함수는 매개변수와 인수의 개수가 일치하는지 체크하지 않는다. 많은 경우에는 무시되고, 적은 경우에는 undefined가 할당된다.
- 초과된 인수는 버려지는 것이 아니라, arguments 객체의 프로퍼티로 보관된다.


### 12.5.2 인수 확인
- 자바스크립트의 경우, 동적 타입언어이므로 매개변수의 타입을 사전에 지정할 수 없다. 
- 그렇기 때문에 함수를 정의할 때, 적절한 인수가 전달되었는지 확인할 필요가 있다.
- 인수 개수를 확인 => arguments 객체를 통해 인수 개수를 확인할 수 있다.
- 인수가 전달되지 않은 경우 => 단축 평가나 매개변수 기본값 지정을 통해 인수의 기본값을 설정할 수 있다.

### 12.5.3 매개변수의 최대 개수
- 함수의 매개변수는 0개가 이상적이며 적으면 적을 수록 좋다.
  - 함수를 호출할 때 전달해야하는 인수의 순서를 고려해야한다.
  - 매개변수의 개수나 순서가 변경되면 함수의 호출방법도 바뀌므로, 유지보수성이 나빠진다.
- 이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 한다.
  - 매개변수가 많다는 것은 함수가 여러가지 일을 한다는 증거
- 여러 개의 매개변수를 전달해야하는 경우, 객체를 인수로 전달하는 것이 유리하다.
  - 프로퍼티의 키만 정확히 지정하면, 순서를 신경쓰지 않아도 됨.

### 12.5.4 반환문
- 함수 호출은 표현식이다. return 키워드가 반환한 표현식의 평가 결과로 평가된다.
- 반환문의 역할
- 1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
- 2. 표현식을 평가해 반환한다. 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
- 반환문은 생략할 수 있다. 이 경우, 암묵적으로 undefined를 반환한다. 
- 함수 몸체에서만 반환문을 사용할 수 있다.

## 12-6. 참조에 의한 전달과 외부 상태의 변경
- 원시타입 인수 : 값 자체가 복사되어 매개변수에 전달 => 원본 값이 변경되는 부수효과가 없음
- 객체타입 인수 : 참조값이 복사되어 매개변수에 전달 => 원본 객체가 변경되는 **부수효과 발생**
  - 함수가 외부 상태를 변경하면 코드의 복잡성을 높이고 가독성을 해친다.
  - 객체를 불변객체로 만들어서 사용하는 것이 대안이 될 수 있음

## 12-7. 다양한 함수의 형태

### 12.7.1 즉시 실행 함수
- 즉시실행함수 (IIFE 패턴) : 함수 정의와 동시에 즉시 호출되는 함수
- 단 한번만 호출되며 다시 호출할 수 없다.
- 기명 즉시 실행함수도 사용할 수 있지만, 무용하여 보통 익명 함수를 사용한다.
- 즉시 실행함수는 반드시 그룹 연산자로 감싸야한다. 그렇지 않으면 에러가 발생한다. 

**사용 예시**
```javascript 
// 1
(function () {
  ...
}());

// 2 
(function (){
  ...
})();

// 3
!function () {
  ...
}();

// 4
+function () {
  ...
}();
```

> 즉시 실행함수 패턴이 여러가지인 점을 이번에 처음 알게 되었음

- 즉시 실행 함수도 값을 반환할 수 있다.
- 즉시 실행 함수도 인수를 전달할 수 있다.

### 12.7.2 재귀 함수
- 재귀 함수 : 재귀 호출을 하는 함수
- 재귀 함수 사용 시에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.
- 반복문 보다 재귀함수를 사용하는 것이 직관적일 때 사용을 권한다.

### 12.7.3 중첩 함수
- 중첩 함수 (내부 함수) : 함수 내부에 정의된 함수
- 외부함수 내부에서만 호출할 수 있다.
- 일반적으로 외부함수를 돕는 헬퍼 함수 역할을 한다.
- ES6 이후부터 if문이나 for문 같은 코드 블록 내에서도 정의할 수 있게 되었다.

### 12.7.4 콜백 함수
- 콜백 함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수 : 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수 ( 혹은 함수를 반환하는 함수 )
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
- 콜백 함수는, 중첩 함수와 마찬가지로, 헬퍼 함수의 역할을 한다. 중첩함수는 교체가 어려운 반면, 콜백함수는 자유롭게 교체할 수 있다는 장점이 있다.
- 콜백 함수는 고차 함수에 의해 호출 시점이 결정되며, 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

### 12.7.5 순수 함수와 비순수 함수
- 순수 함수: 부수효과가 없는 함수
  - 동일한 인수가 전달되면 언제나 동일한 값을 반환
  - 오로지 전달된 인수에게만 의존해 값을 생성해 반환 
  - 최소 하나 이상의 인수를 전달받는다. (인수가 없는 순수함수는 상수와 마찬가지라, 의미가 없다.)
- 비순수 함수 : 외부 상태에 의존하거나, 외부 상태를 변경하는 함수
> 외부상태 : 전역 변수, 서버 데이터, 파일, Console, DOM 등

# 13장 스코프

## 13-1. 스코프란?
- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자를 참조할 수 있는 유효 범위가 결정된다.
- 스코프 : 식별자가 유효한 범위, 식별자를 검색할 때 사용하는 규칙, 네임스페이스
- 식별자 결정 : 자바스크립트 엔진이 어떤 변수를 참조해야하는지 결정하는 것
- 스코프 내에서는 하나의 변수명을 사용해야한다. 다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다.

### var 키워드로 선언한 변수의 중복 선언
- var 키워드로 선언한 변수는 같은 스코프 내 중복 선언되면, 나중에 선언된 것이 var 키워드가 없는 것처럼 값이 재할당 된다.
- let이나 const로 선언된 변수는 중복 선언을 허용하지 않는다.

## 13-2. 스코프의 종류
### 13.2.1 전역과 전역 스코프
- 전역 변수 : 전역에서 선언한 변수, 코드 가장 바깥 영역 뿐만 아니라 함수 에서도 참조할 수 있다. 

### 13.2.2 지역과 지역 스코프
- 지역 : 함수 몸체 내부
- 지역 변수의 유효범위 : 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

## 13-3. 스코프 체인
- 스코프는 함수에 의해 계층적 구조를 갖는다. 이를 스코프 체인이라고 한다.
- 변수를 참조할 때 js엔진은 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

### 13.3.1 스코프 체인에 의한 변수 검색
- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

### 13.3.2 스코프 체인에 의한 함수 검색
- 스코프는 식별자를 검색하는 규칙이라 이해하면 좋다.

## 13-4. 함수 레벨 스코프
- **함수레벨 스코프**: var로 선언된 변수는 오로지 함수의 코드 블록만을 지역스코프로 인정한다.
- C나 자바는 코드 블록이 지역 스코프를 만든다. 이를 **블록 레벨 스코프**라 한다.
- ES6에서 도입된 let, const는 블록 레벨 스코프를 지원한다.

## 13-5. 렉시컬 스코프
- 정적 스코프 (렉시컬 스코프) : 자바스크립트는 함수가 호출된 곳이 아닌 함수가 정의된 곳의 상위 스코프를 기억한다.
- 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.

<br/>

# 14장 전역 변수의 문제점

## 14-1. 변수의 생명주기 
- 변수의 생명주기 : 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지
- 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 된다.
- 스코프도 마찬가지이다.

### 14.1.1 지역 변수의 생명 주기
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다.
- 지역 변수는 함수가 호출되면 생성되고, 함수가 종료하면 소멸한다.
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

### 14.1.2 전역 변수의 생명 주기
- var로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
- 전역 변수의 생명주기는 전역 객체의 생명주기와 일치한다.

## 14-2. 전역 변수의 문제점

### 1. 암묵적 결합
- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다. 

### 2. 긴 생명주기 
- 메모리 리소스를 오랫동안 소비한다.
- 전역 변수의 상태가 변경될 수 있는 시간과 기회가 많아진다. (불변성의 원칙을 해치게 됨)
- 변수 이름이 중복될 가능성이 커진다. 

### 3. 스코프 체인 상에서 종점에 존재
- 스코프 체인 마지막에 위치하게 되면서 검색 속도에 지장을 준다.

### 4. 네임스페이스 오염
- 다른 파일 내 동일한 이름으로 명명된 전역 변수나 전역함수가 같은 스코프 내에 존재하면 에러를 발생시킬 수 있다.

## 14-3. 전역 변수의 사용을 억제하는 방법

### 14.3.1 즉시 실행 함수
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 지역 변수가 된다.

### 14.3.2 네임스페이스 객체
- 네임스페이스 객체를 지정하고 전역 변수처럼 사용하고 싶은 식별자를 프로퍼티로 추가하여 사용한다.

### 14.3.3 모듈 패턴
- 클래스를 모방하여, 관련있는 함수와 변수를 모아 즉시 실행함수로 감싸 하나의 모듈로 만드는 방식
- 클로저를 기반으로 동작
- 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작 메서드를 하나로 묶는 것
- 정보 은닉 : 객체의 특정 프로퍼티나 메서드를 감추는 것
- 모듈 패턴을 사용하면 캡슐화와 정보 은닉을 모두 구현할 수 있다.

### 14.3.4 ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
- script 태그에 `type="module"` 어트리뷰트를 추가하면서 로드된 자바스크립트 파일은 모듈로서 동작함
- 확장자는 mjs를 권장
> **GPT said,**<br/>
> ES6 모듈에서 전역 변수를 사용할 수 없는 이유는 모듈 시스템의 동작 방식 때문입니다. ES6 모듈은 기본적으로 strict mode에서 실행되며, strict mode는 몇 가지 자바스크립트의 안전하지 않은 기능을 비활성화하고 코드 작성의 실수를 예방하는 역할을 합니다.<br/>
모듈은 자체적인 스코프를 가지고 있고, 파일 내에서 선언된 변수는 해당 모듈 내에서만 유효합니다. 따라서 모듈 내에서 선언된 변수는 다른 파일에서 직접적으로 접근할 수 없습니다.

<br/>

# 15장 let, const 키워드와 블록 레벨 스코프

## 15-1. var 키워드로 선언한 변수의 문제점
- ES5까지 변수를 선언할 수 있는 유일한 키워드

### 15.1.1 변수 중복 선언 허용
- 초기화문이 있는 경우의 중복 선언문 : var 키워드가 없는 것처럼 동작
- 초기화문이 없는 경우의 중복 선언문 : 무시

### 15.1.2 함수 레벨 스코프
- 코드 블록 내에서 선언된 변수도 모두 전역 변수가 된다 => 전역 변수의 남발

### 15.1.3 변수 호이스팅
- var 키워드로 선언된 변수는 변수 선언문 이전에 참조할 수 있다.
- 할당문 이전에 변수를 참조하면 undefined를 반환한다.

## 15-2. let 키워드

### 15.2.1 변수 중복 선언 금지
- 이름이 같은 변수를 중복 선언하면 SyntaxError가 발생한다.

### 15.2.2 블록 레벨 스코프
- 모든 코드 블록을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.

### 15.2.3 변수 호이스팅
- 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
- let 으로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다.
- 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
- 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러 ReferenceError가 발생한다.
- 일시적 사각지대 TDZ (Temporal Dead Zone): 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

### 15.2.4 전역 객체와 let
- let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니다.
- 보이지 않는 개념적 블록 내에 존재하게 된다.

## 15-3. const 키워드

### 15.3.1 선언과 초기화
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다.
- 그렇지않으면 SyntaxError 발생
- 블록 레벨 스코프를 가진다.

### 15.3.2 재할당 금지
- 재할당이 금지되어있다.

### 15.3.3 상수
- 원시 값을 할당한 경우 변수 값을 변경할 수 없다.
- 재할당이 금지된 변수
- 상태 유지와 가독성, 유지보수의 편의를 위해 적극 사용해야한다.
- 상수의 경우 스네이크 케이스로 표현하는 것이 일반적이다.

### 15.3.4 const 키워드와 객체
- 객체를 할당한 경우 값을 변경할 수 있다.
- const 키워드는 재할당을 금지할 뿐, 불변을 의미하진 않는다.
- 변경 가능한 값인 객체는 재할당 없이도 변경이 가능하기 때문

## 15-4. var vs let vs const
- 기본 const를 권장하며, 재할당이 필요한 경우에 한해 let으로 변경하는 것이 좋다.