# 28장 Number

## 28-1. Number 생성자 함수
- new Number로 Number 인스턴스를 생성할 수 있다.
- Number 생성자 함수에 인수를 전달하고 new 연산자와 함께 호출하면 _[[NumberData]] 내부 슬롯에 0을 할당한_ Number 래퍼 객체를 생성한다.
- new Number 생성자 함수에 인수로 숫자를 전달하면 내부 슬롯에 숫자를 할당한 Number 래퍼 객체를 생성한다.
- new Number 생성자 함수에 인수로 숫자가 아닌 값을 전달하면 내부 슬롯에 숫자로 변환한 값을 할당하고 Number 래퍼 객체를 생성한다.
  - 숫자로 변환되지 않는 값이라면 NaN이 할당되고 Number 래퍼 객체를 생성한다. 
- new 연산자를 사용하지 않고 Number 생성자 함수를 호출하면 Number 인스턴스가 아닌 숫자를 반환한다.
  - 이를 이용하여 명시적으로 타입을 변환하기도 한다.

## 28-2. Number 프로퍼티

### 28.2.1 Number.EPSILON
- 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.
- 부동소수점 산술 연산은 2진법으로 표현했을 시 미세한 오차가 발생하는 문제가 있다.
- Number.EPSILON은 부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용한다.

### 28.2.2 Number.MAX_VALUE
- 자바스크립트에서 표현할 수 있는 가장 큰 양수값
- Number.MAX_VALUE보다 큰 숫자는 Infinity이다.

### 28.2.3 Number.MIN_VALUE
- 자바스크립트에서 표현할 수 있는 가장 작은 양수값
- Number.MIN_VALUE보다 작은 숫자는 0이다.

### 28.2.4 Number.MAX_SAFE_INTEGER
- 자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값
- 자바스크립트에서 너무나 큰 수가 들어오면 그냥 Infinity가 되버리곤 한다.
- 9007199254740991보다 더 큰 수를 변수에 집어넣어도 저장은 되는데, 그 값을 정확하게 보관할 수 없다는 뜻입니다. (오차발생 가능) // 출처: https://jam-ws.tistory.com/7 [쨈의 작업공간:티스토리]

### 28.2.5 Number.MIN_SAFE_INTEGER
- 자바스크립트에서 안전하게 표현할 수 있는 가장 작은 정수값

### 28.2.6 Number.POSITIVE_INFINITY
- 양의 무한대를 나타내는 숫자값 Infinity와 같은 수

### 28.2.7 Number.NEGATIVE_INFINITY
- 음의 무한대를 나타내는 숫자값 -Infinity와 같은 수

### 28.2.8 Number.NaN
- 숫자가 아님을 나타내는 숫자값
- window.NaN과 같다

## 28-3. Number 메서드

### 28.3.1 Number.isFinite
- ES6 도입되었음
- 유한수인지 검사하여 그 결과값을 불리언 값으로 반환한다.
- *NaN이면 false를 반환한다.
- 빌트인 전역함수 isFinite와 Number.isFinite는 차이가 있다.
  - isFinite는 인수를 숫자로 암묵적 타입 변환한다.
  - Number.isFinite는 인수를 암묵적 타입변환하지 않는다.

> 빌트인 전역함수와 빌트인 객체의 메서드와 차이가 있는지 처음 알게되었음. <br/>
암묵적 타입변환이 일어나지 않는 빌트인 객체의 메서드를 쓰는 것이 좀더 우리가 기대하는 결과를 보는 데 있어서 정확하지 않을까 싶다. 

### 28.3.2 Number.isInteger
- ES6 도입되었음
- 정수인지 검사하여 불리언 타입으로 반환
- 검사하기 전 인수를 암묵적 타입변환하지 않음

### 28.3.3 Number.isNaN
- ES6 도입되었음
- 인수로 전달된 숫자값이 NaN인지 검사하여 불리언 타입으로 반환한다.
- 빌트인 전역함수 isNaN과 차이가 있음
  - isNaN 인수를 숫자로 암묵적 타입 변환한다.
  - Number.isNaN 인수를 암묵적 타입변환하지 않는다.

### 28.3.4 Number.isSafeInteger
- 인수로 전달된 숫자값이 안전한 정수값인지 불리언 값으로 반환한다.

### 28.3.5 Number.prototype.toExponential
- 숫자를 지수 표기법으로 변환하여 문자열로 반환한다.
- 지수표기법 : 매우 큰 숫자나 작은 숫자를 표기할 때 e앞에 있는 숫자에 10의 n승을 곱하는 형식으로 수를 나타내는 방식
- 인수로 소수점 이하로 표기할 자릿수를 전달할 수 있다.
- Number.prototype 메서드를 사용하는 경우 혼란을 방지하기 위해 그룹 연산자를 사용하는 것을 권장한다.
- 소수점 뒤에오는 .+메서드는 잘 작동하나, 정수의 경우 공백을 포함하여 " .메서드"와 같이 써야지 작동한다.

### 28.3.6 Number.prototype.toFixed
- 숫자를 반올림하여 문자열로 반환한다,
- 소수점이하 자릿수를 나타내는 0~20 사이의 정수값을 인수로 전달할 수 있다.
- 인수를 생략하면 기본 0이 지정된다.

### 28.3.7 Number.prototype.toPrecision
- 인수로 전달받은 전체 자릿수까지 유효하도록 나머지 자릿ㅅ를 반올림하여 문자열로 반환한다. 
- 인수로는 전체 자릿수를 나타내는 0~21 사이 정수값을 전달할 수 있다. 
- 인수를 생략하면 기본 0이 지정된다.

### 28.3.8 Number.prototype.toString
- 숫자를 문자열로 변환하여 반환
- 진법을 나타내는 정수값을 인수로 받아 전달할 수 있다.(2~36진법까지)
- 인수를 생략하면 10진법이 지정된다.

<br/>
<br/>
<br/>

# 29장 Math

## 29-1. Math 프로퍼티

### 29.1.1 Math.PI
- 원주율 반환

## 29-2. Math 메서드

### 29.2.1 Math.abs
- 인수로 전달된 숫자의 절대값을 반환

### 29.2.2 Math.round
- 소수점 이하를 반올림한 정수를 반환한다.

### 29.2.3 Math.ceil
- 소수점 이하를 올림한 정수를 반환한다. 

### 29.2.4 Math.floor
- 소수점 이하를 버림한 정수를 반환한다.

### 29.2.5 Math.sqrt
- 제곱근을 반환한다

### 29.2.6 Math.random
- 0에서 1미만의 랜덤 실수를 반환한다.

### 29.2.7 Math.pow
- 첫번째 인수를 밑으로, 두번째 인수를 지수로 거듭제곱한 결과를 반환한다.
- 지수연산자를 사용하여 가독성 좋게 표현할 수 있다. ( 2 ** 2 = 4)

### 29.2.8 Math.max
- 전달받은 인수 중에 가장 큰수를 반환한다. 
- 인수가 전달되지 않으면 -Infinity가 반환된다.
- 배열을 인수로 전달받아 배열 요소중에 최대값을 구하려면 스프레드 문법이나 Function.prototype.apply 메서드를 사용해야한다.

### 29.2.9 Math.min
- 전달받은 인수 중에 가장 작은수를 반환한다.
- 인수가 전달되지 않으면 Infinity가 반환된다.
- 배열을 인수로 전달받아 배열 요소중에 최소값을 구하려면 스프레드 문법이나 Function.prototype.apply 메서드를 사용해야한다.

<br/>
<br/>
<br/>

# 30장 Date
- Date는 표준 빌트인 객체이면서 생성자 함수이다. 
- UTC는 국제 표준시를 말한다. (GMT)
- KST는 UTC에 9시간을 더한 시간이다. 
- 현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정된다.

## 30-1. Date 생성자 함수
- 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다. 

### 30.1.1 new Date()
- 현재 날짜와 시간을 가지는 Date 객체를 반환한다.
- new 연산자 없이 호출하면 날짜와 시간 정보를 나타내는 문자열을 반환한다. 

### 30.1.2 new Date(milliseconds)
- 1970년 1월 1일 00:00:00을 기점으로 인수로 전달된 밀리초만큼 경과된 날짜와 시간을 나타내는 Date 객체를 반환한다.

### 30.1.3 new Date(dateString)
- 날짜와 시간을 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다.
- 인수로 전달한 문자열은 Date.parse 메서드에 의해 해석 가능한 형식이어야한다.

### 30.1.4 new Date(year, month[, day, hour, minute, second, milliseond])
- 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 지정하지 않은 옵션은 0또는1로 초기화된다. 
- 연월을 지정하지 않으면 1970년 1월 1일 00:00:00을 나타내는 Date 객체를 반환한다.

## 30-2. Date 메서드

### 30.2.1 Date.now
- 1970년 1월 1일 00:00:00을 기점으로 현재까지 경과한 밀리초를 수자로 반환한다. 

### 30.2.2 Date.parse
- 1970년 1월 1일 00:00:00을 기점으로 지정시간 까지의 밀리초를 숫자로 반환한다.

### 30.2.3 Date.UTC
- UTC를 기점으로 인수로 전달된 지정시간까지의 밀리초를 숫자로 반환한다.
- month는 월의 의미하는 0~11까지의 정수다. 0부터 시작하므로 주의가 필요하다.

### 30.2.4 Date.prototype.getFullYear
- 연도를 나타내는 정수를 반환한다.

### 30.2.5 Date.prototype.setFullYear
- 연도를 나타내는 정수를 설정한다. 월, 일도 설정할 수 있다.

### 30.2.6 Date.prototype.getMonth
- 월을 나타내는 0~11의 정수를 반환한다.

### 30.2.7 Date.prototype.setMonth
- 월을 나타내는 0~11의 정수를 설정한다. 옵션으로 일도 설정할 수 있다.

### 30.2.8 Date.prototype.getDate
- 날짜를 나타내는 정수를 반환한다.

### 30.2.9 Date.prototype.setDate
- 날짜를 나타내는 정수를 설정한다.

### 30.2.10 Date.prototype.getDay
- 요일을 나타내는 정수를 반환한다.

### 30.2.11 Date.prototype.getHours
- 시간을 나타내는 정수를 반환한다.

### 30.2.12 Date.prototype.setHours
- 시간을 나타내는 정수를 설정한다. 분, 초, 밀리초도 설정할 수 있다.

### 30.2.13 Date.prototype.getMinutes
- 분을 나타내는 정수를 반환한다.

### 30.2.14 Date.prototype.setMinutes
- 분을 나타내는 정수를 설정한다. 초, 밀리초도 설정할 수 있다.

### 30.2.15 Date.prototype.getSeconds
- 초를 나타내는 정수를 반환한다.

### 30.2.16 Date.prototype.setSeconds
- 초를 나타내는 정수를 설정한다. 밀리초도 설정할 수 있다.

### 30.2.17 Date.prototype.getMilliseconds
- 밀리초를 나타내는 정수를 반환한다.

### 30.2.18 Date.prototype.setMilliseconds
- 밀리초를 나타내는 정수를 설정한다.

### 30.2.19 Date.prototype.getTime
- 1970년 1월 1일 00:00:00를 기점으로 경과된 밀리초를 반환한다.

### 30.2.20 Date.prototype.setTime
- 1970년 1월 1일 00:00:00를 기점으로 경과된 밀리초를 설정한다.

### 30.2.21 Date.prototype.getTimezoneOffset
- UTC와 Locale 시간 차이를 분단위로 반환한다.

### 30.2.22 Date.prototype.toDateString
- 사람이 읽을 수 있는 형식의 문자열로 Date 객체의 날짜를 반환한다.

### 30.2.23 Date.prototype.toTimeString
- 사람이 읽을 수 있는 형식으로 Date 객체의 시간을 표현한 문자열을 반환한다.

### 30.2.24 Date.prototype.toISOString
- ISO 8601 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.

### 30.2.25 Date.prototype.toLocaleString
- 인수로 전달한 로캘을 기준으로 날짜와 시간을 표현한 문자열을 반환한다.
- 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.

### 30.2.26 Date.prototype.toLocaleTimeString
- 인수로 전달한 로캘을 기준으로 시간을 표현한 문자열을 반환한다.
- 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.

## 30-3. Date를 활용한 시계 예제
- 교재 내 예시코드 참고(p.576)

<br/>
<br/>
<br/>

# 31장 RegExp

## 31-1. 정규 표현식이란? 
- 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어
- 자바스크립트 고유의 문법은 아니다.
- ES3부터 도입
- 패턴 매칭 기능 : 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.
- 장점 : 조건문과 반복문 없이 패턴을 정의하고 테스트할 수 있어 간단하게 체크할 수 있다.
- 단점 : 여러가지 기호를 혼합하여 사용하고 주석을 허용하지 않기 때문에 가독성이 좋지 않다.

## 31-2 정규 표현식의 생성
- 정규표현식 리터럴을 사용한다. 
  - /패턴/플래그
- RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.
  - 동적으로 생성하게끔 도와줌

## 31-3. RegExp 메서드

### 31.3.1 RegExp.prototype.exec
- 매칭 결과 정보를 배열로 반환한다.
- 매칭 결과가 없는 경우 null을 반환한다.
- g 플래그를 지정해도 첫번째 매칭 결과만 배열로 반환한다.

### 31.3.2 RegExp.prototype.test
- 매칭 결과를 불리언 값으로 반환한다.

### 31.3.3 RegExp.prototype.match
- 매칭 결과를 배열로 반환한다.
- g 플래그를 지정하면 모든 매칭 결과를 배열로 반환한다.

## 31-4. 플래그 
- 정규표현식의 검색 방식을 설정하기 위해 사용한다.
- i : 대소문자를 구별하지 않고 패턴을 검색한다.
- g : 패턴과 일치하는 모든 문자열을 전역 검색한다.
- m : 문자열의 행이 바뀌어도 패턴 검색을 계속한다.
- 플래그 설정이 없을 시 : 첫번째 매칭대상만 검색, 대소문자 구별없이.

## 31-5. 패턴 
- 일정한 규칙을 표현하기 위해 사용
- /로 열고 닫으면 문자열의 따옴표는 생략한다.
- 메타문자 또는 기호로 표현할 수 있다. 

### 31.5.1 문자열 검색
- 문자열을 지정하면 패턴으로 지정한 문자 또는 문자열을 검색한다.

### 31.5.2 임의의 문자열 검색
- . : 임의의 문자 1개를 의미
- 공백도 문자에 포함

### 31.5.3 반복 검색
- {m,n} : 최소 m번 최대 n번 반복되는 문자열
- 콤마 다음에 공백이 들어가지 않도록 유의해야한다.
- {n} : n번 반복되는 문자열
- {n,} : 최소 n번 이상 반복되는 문자열을 의미한다.
- \+ : 최소 1번 이상 반복되는 문자열 == {1,}
- ? : 최대 한번 이상 반복되는 문자열을 의미 == {0,1}

### 31.5.4 OR 검색
- | : or
- `[]` 내부의 문자는 or로 동작한다. 그 뒤에 `+`를 사용하면 앞선 패턴을 한번 이상 반복한다.
- 범위를 지정하려면 `[]` 내부에 `-`를 사용한다.
- 문자 검색 : /[A-Z]+/g
- 숫자 검색 : /[0-9]+/g
- \d == [0-9]
- \D : 숫자가 아닌 문자
- \w : 알파벤, 숫자, 언더스코어 === [A-Za-z0-9_]
- \W : 알파벳, 숫자, 언더스코어가 아닌 문자(공백, 특수문자 등)

### 31.5.5 NOT 검색
- [...] 내의 ^
- \D => [^0-9]
- \W => [^A-Za-z0-9_] 

### 31.5.6 시작 위치로 검색
- [...] 밖의 ^

### 31.5.7 마지막 위치로 검색
- $ : 문자열의 마지막을 의미

## 31-6. 자주 사용하는 정규표현식

### 31.6.1 특정 단어로 시작하는지 검사
- /^https?:\/\//

### 31.6.2 특정 단어로 끝나는지 검사
- /html$/

### 31.6.3 숫자로만 이루어진 문자열인지 검사
- /^[0-9]+$/
- /^\d+$/

### 31.6.4 하나 이상의 공백으로 시작하는지 검사
- \s : 여러가지 공백 문자를 의미한다.
- /^[\s]+/

### 31.6.5 아이디로 사용 가능한지 검사
- /^[A-Za-z0-9]{4,10}$/

### 31.6.6 메일 주소 형식에 맞는지 검사
- 교재 참고

### 31.6.7 핸드폰 번호 형식에 맞는지 검사
- /^\d{3}-\d{3,4}-\d{4}$/

### 31.6.8 특수 문자 포함 여부 검사
- /[^A-Za-z0-9]/gi

<br/>
<br/>
<br/>

# 32장 String

## 32-1. String 생성자 함수
- String 객체는 생성자 함수 객체이다. new 연산자로 호출하여 String 인스턴스를 생성할 수 있다.
- 인수를 전달하지 않고 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다.
  - ES5에서는 [[PrimitiveValue]]라 불렀다.
- 전달된 인수가 [[StringData]]에 할당하고 String 래퍼 객체를 생성한다.
- String 래퍼 객체는 length 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 키로 갖고 각 문자를 프로퍼티 값으로 갖는다.
- 유사배열 객체이면서 이터러블이다.
- 인덱스를 사용하여 문자에 접근할 수 있으나 변경할수는 없다.
- String 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 강제로 문자열로 변환되어 String 래퍼 객체를 생성한다.
- new 연산자 사용없이 String 생성자 함수를 호출하면 문자열을 반환한다. 이를 통해 명시적 타입변환을 하기도 한다.

## 32-2. length 프로퍼티
- 문자열의 문자 개수를 반환한다.

## 32-3. String 메서드 
- String 객체에는 원본 String 래퍼 객체를 변경하는 메서드는 존재하지 않는다.
- 언제나 새로운 문자열을 반환하며 String 래퍼 객체도 읽기 전용 객체로 제공된다.
  - writable 프로퍼티 어트리뷰트 값이 false다. 

### 32.3.1 String.prototype.indexOf
- 인수로 전달받은 문자열을 검색하여 첫번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.
- 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.
- 대상 문자열에 특정문자열이 존재하는지 확인할 때 유용하다.
- ES6 도입된 .includes 메서드를 사용하면 가독성이 더 좋다.

### 32.3.2 String.prototype.search
- 정규표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다.
- 검색에 실패하면 -1을 반환한다.

### 32.3.3 String.prototype.includes
- ES6 도입되었다.
- 인수로 전달받은 문자열이 포함되어있는지 확인하여 그 결과를 불리언 값으로 반환한다.
- 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

### 32.3.4 String.prototype.startsWith
- ES6 도입되었다.
- 인수로 전달받은 문자열로 시작하는지 확인하여 불리언값으로 반환한다. 
- 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

### 32.3.5 String.prototype.endsWith
- ES6 도입되었다.
- 인수로 전달받은 문자열로 끝나는지 확인하여 불리언값으로 반환한다.
- 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

### 32.3.6 String.prototype.charAt
- 인수로 전달받은 인덱스에 위치한 문자를 반환한다.
- 인덱스가 범위를 벗어나면 빈문자열을 반환한다.
- String.prototype.charCodeAt, String.prototype.codePointAt : 유사한 메서드

### 32.3.7 String.prototype.substring
- 첫번째 인수로 전달받은 인덱스에 위치하는 문자부터 두번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.
- substring(1,4) => 인덱스 1부터 3까지 반환
- 두번째 인수는 생략할 수 있다.(끝가지 반환)
- 첫번째 인수가 작아야정상이지만 커도 정상동작한다. 
- 첫번째 인수가 두번째보다 큰 경우 둘의 숫자가 교환된다.
- NaN이거나 0보다 작은 경우 0으로 취급된다.
- 인수가 문자열 길이보다 클 경우 인수는 문자열 길이로 취급된다.
- String.prototype.indexOf 와 함께 사용하면 특정 문자열을 기준으로 앞뒤에 위치한 부분 문자열을 취득할 수 있다.

### 32.3.8 String.prototype.slice
- substring 메서드와 동일하게 동작한다. 그러나 음수인 인수를 전달할 수 있다. 음수 인수를 전달하면 뒤쪽에서부터 문자열 잘라내어 반환한다.

### 32.3.9 String.prototype.toUpperCase
- 대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.

### 32.3.10 String.prototype.toLowerCase
- 대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.

### 32.3.11 String.prototype.trim
- 앞뒤 공백을 제거한 문자열을 반환한다.
- .trimStart : 앞 공백을 제거
- .trimEnd : 뒤 공백을 제거
- .replace 메서드에 정규표현식을 인수로 전달하여 공백 문자를 제거할 수도 있다.

### 32.3.12 String.prototype.repeat
- ES6 도입
- 대상 문자열을 인수로 전달받은 정수만큼 반복하여 새로운 문자열을 반환한다.
- 음수면 RangeError를 발생시킨다. 
- 인수를 생략하면 기본값 0이 설정된다.

### 32.3.13 String.prototype.replace
- 첫번째 인수로 전달받은 문자열 도는 정규표현식을 검색하여 두번째 인수로 전달한 문자열로 치환한 문자열로 반환한다.
- 검색된 문자열이 여럿이라도 첫번째 검색된 문자열만 치한한다.
- 특수한 교체 패턴을 사용할 수 있다. 
  - $& => 검색된 문자열
- 첫번째 인수로 정규표현식을 전달할 수 도 있다.
- 두번째 인수로 치환함수를 전달할 수 있다.
  - 치환함수의 인수로 매치 결과가 전달된다.

### 32.3.14 String.prototype.split
- 첫번째 인수로 전달한 문자열 또는 정규표현식을 검색하여 문자열을 구분한뒤 분리된 각 문자열로 이루어진 배열을 반환한다.
- 인수로 빈 문자열을 전달하면 문자를 모두 분리한다.
- 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.
- 두 번째 인수로 배열의 길이를 지정할 수 있다.
- 배열을 반환하기 때문에 Array.prototype.reverse, Array.prototype.join메서드와 활용하면 활용도가 높다. 
- str.split('').reverse().join('');

<br/>
<br/>
<br/>

# 33장 7번째 데이터 타입 Symbol

## 33-1. 심벌이란?
- 기존 6개 타입에서 ES6에서 추가된 새로운 원시 타입의 값
- 변경 불가능한 원시 타입의 값
- 다른 값과 중복되지 않는 유일무이한 값
- 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용함

## 33-2. 심벌 값의 생성

### 33.2.1 Symbol 함수
- 심벌 값은 Symbol 함수를 호출하여 생성해야 한다.
- 이때 생성된 값은 다른 값과 절대 중복되지 않는 유일무이한 값이다.
- Symbol 함수는 new 연산자와 함께 호출하지 않는다.
- new 연산자로 호출하면 TypeError가 발생한다.
- Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 
  - 이때 전달된 문자열은 심벌값에 대한 설명으로, 디버깅 용도로 사용되며 심벌 값 생성에 어떠한 영향도 주지 않는다.
  - 심벌 값 설명이 같더라도 각각의 심벌값은 유일무이한 값이다.
- 심벌값도 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.
  - Symbol.description => 프로퍼티
  - Symbol.toString() => 메서드
- 심벌값은 암묵적으로 문자열이나 숫자타입으로 변환되지 않는다.
- 그러나, 불리언 값으로는 암묵적 변환될 수 있다.

### 33.2.2 Symbol.for / Symbol.keyFor 메서드
- Symbol.for는 인수로 받은 문자열을 키로 사용하여 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.
  - 전역 심벌 레지스트리(global symbol registry)는 자바스크립트 엔진이 관리하며, 사용 가능한 모든 심볼이 저장되어있다.
  - 키와 심벌값의 쌍들로 저장되어있다.
- 검색 성공 시 : 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.
- 검색 실패 시 : 새로운 심벌 값을 생성하여 Symbol.for 메서드의 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌값을 반환한다.
- Symbol.for 메서드로 심벌을 생성하면 전역 심벌 레지스트리를 통해 공유할 수 있다.
  - 단순히 Symbol 함수로 심벌 값을 생성하면 전역 심벌 레지스트리에 등록되지 않아 검색할 수 없다.
- Symbol.keyFor 메서드를 사용하여 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

## 33.3 심벌과 상수
- 프로퍼티에서 키 자체의 이름이 의미가 있고, 값으로는 무의미한 상수를 사용한다면 심벌 값을 사용할 수 있다.
- 변경/중복 가능성 x

### cf) enum
- 명명된 숫자 상수의 집합으로 열거형이라고 부른다.
- 자바스크립트에선 지원하지 않지만 타입스크립트에선 지원된다.
- 자바스크립트에선 enum을 흉내내기 위해 Object.freeze와 심벌값을 사용한다.

## 33.4 심벌과 프로퍼티 키
- 동적으로 프로퍼티 키를 심벌 값으로 생성할 수 있다.
- 대괄호를 통해 구현할 수 있다.
- 다른 프로퍼티 키와 절대 충돌하지 않게 된다.

## 33.5 심벌과 프로퍼티 은닉
- 심벌 값을 프로퍼티 키로 사용하면 for...in문이나 Object.keys, Object.getOwnPropertyNames 메서드로 찾을 수 없다. 
- 그래서 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다. 
- ES6에 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

## 33.6 심벌과 표준 빌트인 객체 확장
- 일반적으로 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하는 것을 권장하지 않는다.
  - 기존 메서드와의 충돌 위험 때문
- 하지만 심벌 값으로 프로퍼티 키를 생성하여 확장하면 상위버전 확장에도 충돌 위험없이 표준 빌트인 객체를 확장할 수 있다. 

## 33.7 Well-known Symbol
- Well-known Symbol : 자바스크립트가 기본 제공하는 빌트인 심벌 값
- 자바스크립트 엔진 내부 알고리즘에 사용된다.
- 순회 가능한 빌트인 이터러블은 Symbol.iterator를 키로 갖는 메서드를 가지며, Symbol.iterator 메서드를 호출하면 이터레이터를 반환하도록 규정되어있다.
  - 빌트인 이터러블은 이 이터레이션 프로토콜을 준수한다.
  - 일반 객체도 이터러블 처럼 구현하고 싶다면 이터레이션 프로토콜을 준수하면 된다.
  - Symbol.iterator를 키로 갖는 메서드를 추가하고, 이터레이터를 반환 => 이터러블이 된다. 

<br/>
<br/>
<br/>

# 34장 이터러블

## 34-1. 이터레이션 프로토콜 
- 순회가능한 데이터 컬렉션을 만들기 위해 ECMA Script 사양에 정의하여 미리 약속한 규칙이다.
- ES6에서 도입되었다. 
- ES6부터는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하였다. 
- for...of 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 하였다.

#### 이터레이션 프로토콜
- 이터러블 프로토콜
  - Well-known Symbol인 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환하는 규약
  - 이터러블 프로토콜을 준수한 객체 => **이터러블**
  - for...of 문으로 순회 가능
  - 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.
- 이터레이터 프로토콜
  - 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환하고 이터레이터는 next 메서드를 소유하며, 이를 호출하면 이터러블을 순회하면 value와 done 프로퍼티를 갖는 이터레이터 result 객체를 반환하는 규약
  - 이터레이터 프로토콜을 준수한 객체 => **이터레이터**
  - 이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다.

### 34.1.1 이터러블
- 이터러블 프로토콜을 준수한 객체
- Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체
- 배열, 문자열, Map, Set
- 이터러블은 for...of 문으로 순회할 수 있으며, 스프레드 문법과 디스트럭처링 할당의 대상으로 사용할 수 있다.

#### 이터러블이 아닌 일반 객체
- Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.
- for...of 문으로 순회할 수 없고 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.
- 일반 객체 리터럴도 스프레드 문법의 사용을 허용하도록 바뀌었다.

### 34.1.2 이터레이터
- 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터를 반환한다.
- Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.
- next 메서드는 각 요소를 순회하기 위한 포인터 역할을 한다. 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.
- 이터레이터 리절트 객체에는 현재 순회중인 값을 나타내는 value 프로퍼티와 순회 완료 여부를 나태나는 done 프로퍼티를 갖는다.

## 34-2. 빌트인 이터러블
- Array : Array.prototype[Symbol.iterator]
- String : String.prototype[Symbol.iterator]
- Map : Map.prototype[Symbol.iterator]
- Set : Set.prototype[Symbol.iterator]
- TypedArray : TypedArray.prototype[Symbol.iterator]
- arguments : arguments[Symbol.iterator]
- DOM 컬렉션 : NodeList.prototype[Symbol.iterator], HTMLCollection.prototype[Symbol.iterator]

## 34-3. for...of 문
- 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.
- for (변수 선언문 of 이터러블) {...}
- 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회한다.
- next 메서드가 반환한 iterator result 객체의 value 프로퍼티 값을 for...of 변수에 할당한다. 그리고 done 프로퍼티 값이 false이면 순회를 계속하고 true이면 중단한다.

## 34-4. 이터러블과 유사 배열 객체
- 유사배열객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할수 있고 length 프로퍼티를 갖는 객체
- 유사배열 객체는 일반 객체이기 때문에 Symbol.iterator 메서드가 없고 for...of문으로 순회할 수 없다.
- 단 arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.
  - ES6에서 이터러블이 도입되면서 해당 유사배열객체들이 Symbol.iterator를 구현하면서 이터러블이 되었다. 
- 배열도 ES6에서 이터러블이 되었다.
- 유사배열객체는 Array.from 메서드를 통해 배열로 간단히 변환할수있다. 
  - 인수로 유사배열객체 또는 이터러블을 받아 배열로 반환한다.

## 34-5. 이터레이션 프로토콜의 필요성
- ES6 이저에는 각자의 방식으로 순회하였으나 ES6부터 이터레이션 프로토콜을 통해 이터러블을 통일하고 for...of, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 하였다. 
- 이터레이션 프로토콜을 통일함으로서 데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 하게 되었다.

## 34-6. 사용자 정의 이터러블

### 34.6.1 사용자 정의 이터러블 구현
- 내부적으로 이터레이션 프로토콜을 준수하도록 구현한다면 일반객체도 이터러블이 될 수 있다. 

### 34.6.2 이터러블을 생성하는 함수
- 교재 예시코드 참고 p.623

### 34.6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수
- 이터러블이면서 이터레이터인 객체를 생성하면 Symbol.iterator 메서드를 호출하지 않아도 된다.

### 34.6.4 무한 이터러블과 지연 평가
- 무한 이터러블을 생성하는 함수를 정의함으로서 무한수열을 구현할 수 있다.
- 지연 평가 : 데이터가 필요한 시점 전까지는 미리 데이터를 생성하지 않다가 데이터가 필요한 시점이 되면 그때야 비로소 데이터를 생성하는 기법
- 지연평가를 사용하면 불필요한 데이터를 미리 생성하지 않고 필요한 데이터를 필요한 순간에 생성하여 빠른 실행속도와 불필요한 메모리 소비를 막는 것을 기대할 수 있고, 무한도 표현할 수 있다는 장점이 있다.
<br/>
<br/>
<br/>

# 35장 스프레드문법
- 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.
- 순회할 수 있는 이터러블에 한정하여 사용할 수 있다.

## 35-1. 함수 호출문의 인수 목록에서 사용하는 경우
- 함수의 인수 목록에 배열을 펼쳐서 전달하면 더욱 간결하고 가독성있게 표현할 수 있다.
- Rest 파라미터(...rest)와 혼동하지 않도록 유의해야한다. 둘은 반대의 개념이다.

## 35-2. 배열 리터럴 내부에서 사용하는 경우

### 35.2.1 concat
- 기존 : [].concat([])
- 스프레드(ES6) : [...[], ...[]]

### 35.2.2 splice
- 기존 : Array.prototype.splice.apply(arr1, [1, 0].concat(arr2))
- 스프레드(ES6) : arr1.splice(1, 0, ...arr2)

### 35.2.3 배열 복사
- 기존 : copy = origin.slice();
- 스프레드 (ES6) : copy = [...origin]
- 둘 다 얕은 복사이다.

### 35.2.4 이터러블을 배열로 변환
- 기존 : 이터러블을 배열로 변환하기 위해 apply, call 메서드를 사용하여 slice메서드를 호출했어야했다.
- 스프레드 : [...arguments].reduce(...)
- Rest 파라미터를 통해 인수들의 목록을 배열로 전달받아 활용할수도 있다.
- 이터러블이 아닌 유사배열객체는 스프레드 문법의 대상이 될 수 없다. (arguments 객체는 이터러블이면서 유사배열객체이다.)

## 35-3. 객체 리터럴 내부에서 사용하는 경우
- 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.
- 이전에는 Object.assign 메서드를 사용하여 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경 또는 추가했다.
  - 뒤에 오는 프로퍼티가 우선권을 가졌다. 
- 스프레드 : {...{x:1, y:2}, y:100 } => {x:1, y:100}

<br/>
<br/>
<br/>

# 36장 디스트럭처링 할당
- 구조화된 배열과 같은 이터러블 또는 객체를 비구조화하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 

## 36-1. 배열 디스트럭처링 할당
- const [a, b, c] = [1, 2, 3]
- 우변은 이터러블이여야 하며, 기준은 인덱스다.
- 반드시 변수의 개수와 요소개수가 일치할 필요는 없다. 
- 변수에 기본값을 설정할 수 있다.
- rest 요소를 활용할 수도 있다. 맨 마지막에 위치해야한다.
  - [x, ...y] = [1, 2, 3]
  - y => [2, 3]

## 36-2. 객체 디스트럭처링 할당
- const {firstname, lastname} = user;
- 할당 기준은 프로퍼티 키이다.
- 키와 다른 이름으로 할당받으려면 다음과 같이 선언해야한다. 
  - const {firstname: fn, lastname: ln} = user;
- 변수에 기본값을 설정할 수 있다.
- 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.
- 매개변수에도 사용하여 가독성을 늘릴 수 있다. 
  - function foo({content, completed}){...}
- 배열의 요소가 객체인 경우 배열 비구조화할당과 객체 비구조화할당을 혼용할 수 있다.
- 중첩 객체의 경우
  - const {address : {city}} = user
- rest 요소를 활용할 수도 있다. 맨 마지막에 위치해야한다.

<br/>
<br/>
<br/>

# 37장 Set과 Map

## 37-1. Set
- Set 객체는 중복되지 않는 유일한 값들의 집합이다.
- 요소 순서에 의미가 없다
- 인덱스로 요소에 접근할 수 없다.
- 중복된 값을 포함하지 않는다. 
- 수학적 집합을 표현하기 위한 자료구조인 까닭으로, 교집합, 차집합, 합집합, 여집합 등을 구현할 수 있다.

### 37.1.1 Set 객체의 생성
- new Set()
- 이터러블을 인수로 받아 set 객체를 생성하며 이터러블의 중복된 값은 요소로 저장되지 않는다.
  - 이러한 특성을 활용해 배열의 중복된 요소를 제거할 수 있다.

### 37.1.2 요소 개수 확인
- Set.prototype.size 프로퍼티를 활용한다.
- getter 함수만 존재하는 접근자 프로퍼티이다. 임의로 변경할 수 없다.

### 37.1.3 요소 추가
- Set.prototype.add 메서드를 사용한다.
- 새로운 set 객체가 반환된다. 
- 메서드 체이닝을 통해 연속적으로 호출할 수 있다.
- 중복된 요소를 추가해도 추가되지 않으며 무시된다.
- NaN과 NaN을 같다고 판별하여 중복 추가를 허용하지 않는다.
- +0과 -0은 같다고 평가하여 중복 추가를 허용하지 않는다.
- 모든 값을 요소로 저장할 수 있다.

### 37.1.4 요소 존재 여부 확인
- Set.prototype.has 메서드를 사용한다.
- 불리언 값을 반환한다.

### 37.1.5 요소 삭제
- Set.prototype.delete 사용한다.
- 삭제 성공 여부를 나타내는 불리언 값을 반환한다.
- 삭제하려는 요소값을 인수로 전달해야한다.
- 존재하지 않는 요소값을 삭제하려하면 에러없이 무시된다. 
- add와 다르게 연속적으로 호출할 수 없다.

### 37.1.6 요소 일괄 삭제
- Set.prototype.clear 메서드
- 언제나 undefined를 반환한다.

### 37.1.7 요소 순회
- Set.prototype.forEach 메서드
  - this로 사용될 객체를 인수로 전달한다. 콜백함수는 3개의 인수를 전달받는다. 
  - 1 : 순회중인 요소값
  - 2 : 순회중인 요소값
  - 3 : 순회 중인 Set 객체 자체
  - 첫번째 인수와 두번째인수는 같은 값이다. Array.prototype.forEach와 인터페이스를 통일하기 위함이다. 
- Set은 이터러블이다. for...of로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링의 대상이 될 수 있다.
  - 요소에 순서를 갖지 않지만 순회하는 순서는 추가된 순서를 따른다.

### 37.1.8 집합 연산

**교집합**
- Set.prototype.intersection 구현 코드
- .has를 통해 공통 요소를 검증하여 결과값에 리턴한다.

**합집합**
- .add를 통해 모든 요소들을 추가하여 결과값을 리턴한다.
- 다음과 같이도 구현 가능하다. 
  - new Set([...setA, ...setB])

**차집합**
- A-B : A에는 존재하지만 B에는 존재하지 않는 요소들
- 한쪽의 값이 다른 한쪽을 순회하면서 존재여부를 확인하고 .delete를 통해 복사한 Set에서 삭제한다.
- has를 통해서도 검증하여 구현할 수 있다.

**부분집합과 상위집합**
- A ㄷ B
- .has를 통해 모든 요소가 상위 집합에 있는지 확인한다.
- 배열로 복사하여 .every와 .includes를 활용하여 구현 할수도 있다.

## 37-2. Map
- 키와 값의 쌍으로 이뤄진 컬렉션이다. 객체와 유사하다. 
- 객체와 다르게 이터러블이다. 

### 37.2.1 Map 객체의 생성
- new Map()
- 이터러블을 인수로 받아 Map 객체를 생성한다. 

### 37.2.2 요소 개수 확인
- Map.prototype.size
- getter 함수만 존재하는 접근자 프로퍼티이다. 임의로 변경할 수 없다.

### 37.2.3 요소 추가
- Map.prototype.set
- 결과로서 새로운 요소가 추가된 Map 객체를 반환한다.
- 메서드 체이닝 할 수 있다.
- 키 타입에 제한이 없다. 모든 값을 키로 사용할 수 있다.
- 중복된 키를 갖는 요소를 추가하면 덮어씌워진다. 
- NaN과 NaN을 같다고 판별하여 중복 추가를 허용하지 않는다.
- +0과 -0은 같다고 평가하여 중복 추가를 허용하지 않는다.

### 37.2.4 요소 취득
- Map.prototype.get
- 키를 인수로 전달한다.
- 요소가 없다면 undefined가 반환된다.

### 37.2.5 요소 존재 여부 확인
- Map.prototype.has
- 불리언 값을 반환한다.

### 37.2.6 요소 삭제
- Map.prototype.delete
- 존재하지 않는 키로 삭제하려하면 에러없이 무시된다.
- 삭제 성공여부를 불리언 값으로 반환한다. 그러므로 체이닝하여 사용할 수 없다.

### 37.2.7 요소 일괄 삭제
- Map.prototype.clear
- 언제나 undefined를 반환한다.

### 37.2.8 요소 순회
- Map.prototype.forEach
  - 1: 순회중인 요소의 값
  - 2: 순회중인 요소의 키
  - 3: 순회중인 Map 객체 자체
- Map 객체는 이터러블이다. for...of 로 순회가능하고, 스프레드문법과 배열 디스트럭처링 할당의 대상이 될 수 있다.
- 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.
  - Map.prototype.keys
  - Map.prototype.values
  - Map.prototype.entries
- Map 객체는 요소의 순서가 없지만 순회하는 순서는 요소가 추가된 순서를 따른다.

