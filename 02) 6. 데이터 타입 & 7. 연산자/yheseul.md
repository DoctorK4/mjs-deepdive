# 06장 데이터 타입
💡 자바스크립트의 모든 값은 데이터 타입(값의 종류)을 갖고, 원시 타입과 객체 타입으로 분류된다.

  - 원시 자료형 (Primitive data type) = 원시 타입
    : 정수, 실수, 문자, 논리 리터럴등의 “하나”의 실제 데이터 값을 저장, 원시 자료형이 할당될 때에는 변수에 값(value) 자체가 담긴다.
    - 숫자(number) 타입 : 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
    - 문자열(string) 타입 : 문자열(변경 불가능한 값)
    - 불리언(boolean) 타입 : 논리적 참(true)과 거짓(false)
    - undefined 타입 : var 키워드로 선언된 변수에 암묵적으로 할단되는 값
    - null 타입 : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
    - 심벌(symbol) : ES6에서 추가된 7번째 타입

  - 참조 자료형 (Reference data type) = 참조 타입, 객체 타입
    : 객체(Object)의 주소를 참조(저장)하는 타입으로 메모리 주소(reference)를 통해 객체를 참조, 참조 자료형이 할당될 때는 보관함의 주소(reference)가 담긴다.
    - 객체, 함수, 배열 등

## 6.1 숫자 타입
💡 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

  - Infinity : 양의 무한대
  - -Infinity : 음의 무한대
  - NaN : 산술 연산 불가(not-a-number) => *대소문자 구별(Nan,nan 등은 에러 발생, 식별자로 해석)

## 6.2 문자열 타입
💡 문자열 타입은 키워드나 식별자 같은 토큰과 구분하기 위해 작은따옴표(''), 큰따옴표(""), 백틱(``)으로 텍스트를 감싸서 텍스트 데이터를 나타낸다.

## 템플릿 리터럴
💡 ES6부터 템플릿 리터럴이라혹 하는 새로운 문자열 표기법 도입, 일반 문자열과 비슷해 보이지만 일반적인 따옴표 대신 백틱(``)을 사용해 표현한다.

## 6.3.1 멀티라인 문자열
💡 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용, 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않아도 된다. 

|이스케이프 시퀀스|의미|
|:---|:---|
|\0|Null|
|\b|백스페이스|
|\f|폼 피드LF, Line Feed : 다음 행으로 이동|
|\n|개행LF, Lind Feed : 다음 행으로 이동|
|\r|개행CR, Carriage Return : 커서를 처음으로 이동|
|\t|탭(수폄)|
|\v|탭(수직)|
|\uXXXX|유니코드, 예를 들어 '\u0041'은 'A', '\uD55C'는 '한', '\u{1F600}'는 😀이다.|
|\'|작은따옴표|
|\"|큰따옴표|
|\\|백슬래시|

### 6.3.2 표현식 삽입
문자열은 문자열 연산자(+)를 사용해 연결할 수 있다.(+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고 그 외의 경우는 덧셈 연산자로 동작한다.)

[ 예제 06-12 ]
var first = 'ung-mo';
var last = 'Lee';

// ES5 :  문자열 연결
consol.log('My name is' + first + ' ' + last + '.'); // My name is Ung-mo Lee.

💡 템플릿 리터럴 내에서는 ${}으로 표현식을 감싸는 표현식 삽입을 통해 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합해 간단히 문자열을 삽입할 수 있다.

[ 예제 06-13 ]
var first = 'ung-mo';
var last = 'Lee';

// ES6 :  표현식 삽입
consol.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.

## 6.4 불리언 타입
💡 불리언 타입의 값은 논리적 참(true)과 거짓(flase)만 표현되므로 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에 자주 사용된다.

## 6.5 undefined 타입
💡 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 자바스크립트 엔진이 undefined로 초기화한다.

## 6.6 null 타입
💡 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.

## 6.7 심벌 타입
💡 ES6에서 추가된 7번째 타입으로, 심벌은 변경 불가능한 원시 타입의 값이며, 다른 값과 중복되지 않는 고유한 값.


  - 심벌은 필드를 객체 내부에 숨기기 위해서 외부에 노출되지 않아 사용 접근 방법이 없기 때문에 외부에서 값을 변경할 수 없음. 
  - 내부 필드를 그냥 문자열이 아니라 Symbol로 선언한다면 private 필드라는걸 직관적으로 알려줄 수 있음.
  - 가독성 뿐만아니라 안전한 코드를 작성하는데 도움을 줌.
  - 같은 문자열처럼 키 값을 우연히 중복되게 쓸 일 자제가 없다.
  - Symbol을 통해서 해당 변수에 추가적인 의미를 줄 수 있다.
  - 키 값이 겹쳐서 꼬이는 걸 방지.

### 심볼의 고유성
  : 심볼 값은 동일하지만, 각 심볼은 고유하기때문에 동일 연사자(==)로 비교 시 false가 반환.

  [ 예제 ]
  const me = Symbol('철수');
  const clone = Symbol('철수');

  console.log(me == clone); // false

### 심볼이 객체 속성일때
  : people 객체에서 이름이 같은. 즉, 속성이 같을때 겹치는 것을 피하기 위해서 심볼을 사용.

  [ 예제 ]
  const people = {
    [Symbol("철수")] : "friend",
    [Symbol("영미")] : "friend",
    [Symbol("철수")] : "brother",
  };

  for (person in people) {
    console.log(person)
  }
  // undefined

  출력이 undefined인 이유는 심볼은 for...in에서 배제되어 반복 불가능.
  Object.getOwnPropertySymbols() 사용하여 객체의 속성들의 배열 획득.

  [ 예제 ]
  const people = {
	[Symbol("철수")] : "friend",
  [Symbol("영미")] : "friend",
  [Symbol("철수")] : "brother",
};

  const symbols = Object.getOwnPropertySymbols(people);
  console.log(symbols); // [Symbol(철수), Symbol(영미), Symbol(철수)]
  const value = symbols.map(symbol => people[symbol]); // 배열 속성에 접근을하기 위해 map을 사용
  console.log(value);
// (3) ['friend', 'friend', 'brother']
    0: "friend"
    1: "friend"
    2: "brother"
    length: 3

## 6.8 객체 타입
💡 자바스크립트를 이루고 있는 거의 모든 것이 객체

## 6.9 데이터 타입의 필요성
### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조
  : 메모리에 값을 저장하려면 먼저 확보해야 할 메모리의 공간의 크기를 결정해야 한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다. 이러한 메모리 셀의 크기를 결정하기 위해 데이터 타입을 활용해 메모리 공간을 확보한다. 

### 6.9.2 데이터 타입에 의한 값의 해석
  : 모든 값은 데이터 타입을 가지며, 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있음. 

  - 데이터 타입이 필요한 이유
    - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
    - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
    - 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

## 6.10 동적 타이핑
### 6.10.1 동적 타입 언어와 정적 타입 언어
  - 정적 타입 언어 
    - 변수에 타입 변경 불가능, 변수에 선언한 타입에 맞는 값만 할당 가능.
    - 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리) 수행해 런타임에 발생하는 에러를 감소시킴.

  - 동적 타입 언어
    - 변수에 어떤 데이터 타입의 값이 와도 자유롭게 할당 가능.
    - 변수는 선언이 아닌 할당에 의해 타입 결정(타입 추론).
    - 재할당에 의해 언제든지 동적으로 변경 가능.
    - 변수가 타입을 가지는 것이 아닌 값이 타입을 가지므로 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정.

### 6.10.2 동적 타입 언어와 변수
  : 동적 타입 언어는 변수 값이 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수의 값을 추적하기 어려울 수 있고, 타입도 언제든지 변경될 수 있어 유연성은 높지만 신뢰성은 떨어진다. 

  - 가독성 좋은 코드를 위한 변수 사용시 주의점
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용.
    - 변수의 유효 범위(스코프)가 넓으면 넓을수록 변수에 의해 오류가 발생할 확률이 높으므로 최대한 좁게 만들어 부작용 억제.
    - 전역 변수는 처리 흐름은 추적하기 어려워 오류가 발생할 경우 오류의 원인을 특정하기 어려우므로 사용을 지양.
    - 변수보다는 상수를 사용해 값의 변경을 억제.
    - 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍.

-------------------------------------------------------------------------------------

# 07장 연산자
💡 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 피연산자는 연산의 대상으로서 값으로 평가될 수 있는 표현식이고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.

## 7.1 산술 연산자
💡 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환.

### 7.1.1 이항 산술 연산자
  : 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

  |이항 산술 연산자|의미|부수 효과|
  |:---:|:---|:---:|
  |+|덧셈|X|
  |-|뺄셈|X|
  |*|곱셈|X|
  |/|나눗셈|X|
  |%|나머지|X|

### 7.1.2 단항 산술 연산자
  : 1개의 피연산자를 산술 연산하여 숫자 값을 만든다. **증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과를 가짐(암묵적 할당)**

  |단항 산술 연산자|의미|부수 효과|
  |:---:|:---|:---:|
  |++|증가|O|
  |--|감소|O|
  |+|어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.|X|
  |-|양수를 음수로, 음수를 양수로 반전한 값을 반환한다.|X|

  [ 예제 07-04 ]
  var x = 5, result;

  // 선할당 후증가
  result = x++;
  console.log(result, x); // 5 6

  // 선증가 후할당
  result = ++x;
  console.log(result, x); // 7 7

  // 선할당 후감소
  result = x--;
  console.log(result, x); // 7 6

  // 선감소 후할당
  result = --x;
  console.log(result, x); // 5 5

- + 단항 연산자를 이용한 숫자 타입으로의 변환
  : 피연산자를 변경하는 것이 아닌 숫자 타입으로 변환한 값을 생성해서 반환하는 것으로 부수 효과는 없다.

  [ 예제 07-06 ]
  var x = '1';

  // 문자열을 숫자로 타입 변환
  console.log(+x); // 1
  // 부수 효과는 없다.
  console.log(x); // '1'

  // 불리언 값을 숫자 타입으로 변환
  x = true;
  console.log(+x); // 1
  // 부수 효과는 없다.
  console.log(x); // true

  // 불리언 값을 숫자 타입으로 변환
  x = flase;
  console.log(+x); // 0
  // 부수 효과는 없다.
  console.log(x); // false

  // 문자열을 숫자 타입으로 변환할 수 없으므로 NaN을 반환
  x = 'Hello';
  console.log(+x); // NaN
  // 부수 효과는 없다.
  console.log(x); // 'Hello'

### 7.1.3 문자열 연결 연산자
  : + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작(그 외의 경우는 산술 연산자로 동작)

  [ 예제 07-08 ]
  // 문자열 연결 연산자
  '1' + 2; // '12'
  1 + '2'; // '12'

  // 산술 연산자
  1 + 2; // 3

  // true는 1로 암묵적 타입 변환(타입 강제 변환)
  1 + true; // 2

  // flase는 0으로 암묵적 타입 변환(타입 강제 변환)
  1 + false; // 1

  // null은 0으로 암묵적 타입 변환(타입 강제 변환)
  1 + null; // 1

  // undefined는 숫자로 타입 변환되지 않는다.
  +undefined; // NaN
  1 + undefined; // NaN

## 7.2 할당 연산자
💡 할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다. 

|할당 연산자|예|동일 표현|부수 효과|
|:---:|:---|:---|:---:|
|=|x = 5|x = 5|O|
|+=|x += 5|x = x + 5|O|
|-=|x -= 5|x = x + 5|O|
|*=|x *= 5|x = x * 5|O|
|/=|x /= 5|x = x / 5|O|
|%=|x %= 5|x = x % 5|O|

**할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.**

## 7.3 비교 연산자
💡 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환. 

### 7.3.1 동등/일치 비교 연산자
  |비교 연산자|의미|사례|설명|부수 효과|
  |:---:|:---:|:---:|:---|:---:|
  |==|동등 비교|x == y|x와 y의 값이 같음|X|
  |===|일치 비교|x === y|x와 y의 값과 타입이 같음|X|
  |!=|부동등 비교|x != y|x와 y의 값이 다름|X|
  |!==|불일치 비교|x !== y|x와 y의 갑과 타입이 다름|X|

  - **동등 비교(==) 연산자** : 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
  - **일치 비교(===) 연산자** : 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
    - 일치 비교 연산자에서 주의할 것은 **NaN**이다.

    [ 예제 07-15 ]
    // NaN은 자신과 일치하지 않는 유일한 값.
    NaN === NaN; // false

  - 숫자가 NaN인지 조사하려면 Number.isNaN()을 사용
  - 양의 0과 음의 0을 비교하면 true를 반환

    [ 예제 07-17 ]
    // 양의 0과 음의 0의 비교, 일치 비교/동등 비교 모두 true를 반환
    0 === -0; // true
    0 == -0; // true

### 7.3.2 대소 관계 비교 연산자
  : 피연산자의 크기를 비교하여 불리언 값을 반환.
  
  |대소 관계 비교 연산자|예제|설명|부수 효과|
  |:---:|:---:|:---|:---:|
  |>|x > y|x가 y보다 크다|X|
  |<|x < y|x가 y보다 작다|X|
  |>=|x >= y|x가 y보다 크거나 같다|X|
  |<=|x <= y|x가 y보다 작거나 같다|X|

## 7.4 삼항 조건 연산자
💡 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값. **삼항 조건 연산자 표현식은 갑승로 평가할 수 잇는 표현식인 문**

[ 예제 07-21 ]
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수

## 7.5 논리 연산자
💡 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.

|논리 연산자|의미|부수 효과|
|:---:|:---|:---:|
||||논리합(OR)|X|
|&&|논리곱(AND)|X|
|!|부정(NOT)|X|

- 드 모르간의 법칙
  : 논리 연산자로 구성된 복잡한 표현식에서 가독성이 좋지 않아 한눈에 이해하기 어려울 때 드 모르간의 법칙을 활용

  [ 예제 07-28 ]
  !(X || y) === (!x && !y)
  !(x && y) === (!x || !y)

## 7.6 쉼표 연산자
💡 왼쪽 피 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환.

[ 예제 07-29 ]
var x, y, z;

x = 1. y = 2, z = 3; // 3

## 7.7 그룹 연산자
💡 소괄호('()')로 피연산자를 감싸 자신의 피연산자인 표현식을 가장 먼저 평가해 연산자의 우선순위를 조절할 수 있다. 

[ 예제 07-30 ]
10 * 2 + 3; // 23

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // 50

## 7.8 typeof 연산자
💡 피연산자의 데이터 타입을 문자열로 반환. ("string", "number","boolean","undefined","symbol","object","function")

- 값이 null 타입인지 확일할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용

[ 예제 07-32 ]
var foo = null;

typof foo === null; // false
foo === null; // true

- 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 아닌 undefined를 반환.

[ 예제 07-33 ]
// undefined 식별자를 선언한 적이 없다.
typeof undeclared; // undefined

## 7.9 지수 연산자
💡 ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환.

[ 예제 07-34 ]
2 ** 2; // 4
3 ** 2; // 9

// 음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶음
(-5) ** 2; // 25 

// 할당 연산자와 함께 사용 가능
var num = 5;
num **= 2; // 25

// 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높음.
2 * 5 ** 2; // 50

## 7.10 그 외의 연산자

|연산자|개요|
|:---|:---|
|?.|옵셔널 체이닝 연산자|
|??|null 병합 연산자|
|delete|프로퍼티 삭제|
|new|생성자 함수를 호출할 때 사용하여 인스턴스 생성|
|instanceof|좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별|
|in|프로퍼티 존재 확인|

## 7.11 연산자의 부수 효과
💡 대부분의 연산자는 다른 코드에 어떠한 영향도 주지 않고 새로운 값을 생성할 뿐이지만, 부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.

[ 예제 07-40 ]
var o = { a: 1 };

// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다. 이는 0 객체를 사용하는 다른 코드에 영향을 준다.
delete o.a;
console.log(o); // {}

## 7.12 연산자 우선순위
💡 연산자는 종류가 많아서 우선순위를 모두 기억하기 어려우므로 그룹 연산자를 사용하여 우선순위를 명시적으로 조잘하는 것을 권장.

|우선순위|연산자|
|:---:|:---|
|1|()|
|2|new(매개변수 존재),.,[](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)|
|3|new(매개변수 미존재)|
|4|x++, x--|
|5|!x, +x, -x, ++x, --x, typeof, delete|
|6|**(이항 연산자 중에서 우선순위가 가장 높다)|
|7|*, /, %|
|8|+, -|
|9|<, <=, >, >=, in, instanceof|
|10|==, !=, ===, !==|
|11|??(null 병합 연산자)|
|12|&&|
|13||||
|14|? ... : ...|
|15|할당 연산자(=, +=, -=, ...)|
|16|,|

## 7.13 연산자 결합 순서
💡 연산자 결합 순서랑 연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서.

|결한 순서|연산자|
|:---|:---|
|좌항 -> 우항|+, -, /, %. <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof|
|우항 -> 좌항|++, --, 할당 연산자(=, +=, -=, ...), !x, +x, ++x, --x, typeof, delete, ? ... : ...|


