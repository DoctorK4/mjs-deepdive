# 6. 데이터 타입

- 데이터 타입이란? : 값의 종류
- 자바스크립트의 모든 값은 데이터 타입을 갖는다.
- ES6 기준 7개의 타입, ES11 기준 8개의 타입이 있다.(BigInt가 추가되었음.)
- 각각의 타입은 크게 원시타입과 객체 타입(객체, 함수, 배열)로 구분지을 수 있다.

## 6-1. 숫자 타입

- 하나의 숫자타입만 존재한다.(정수, 실수, 음의 정수 모두 )

```javascript
1 === 1.0;
```

- 모두 2진수 부동 소수점 형식으로 저장한다.

> **부동소수점?**
> <br/> 부동소수점(浮動小數點, floating point) 또는 떠돌이 소수점[1] 방식은 실수를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다. <위키백과>

> 2진수로 표현하는 과정에서 부득이하게 근사치가 저장되는 경우가 있음
> <br/> ex) 0.3 => 0.01001100110011

- Infinity
- -Infinity
- NaN

> NaN은 무슨 타입인가? null은 무슨 타입인가? 비교 질문 나올 수 있을 듯 하다.

## 6-2. 문자열 타입

- UTF-16 : 0개 이상의 16비트 유니코드 문자의 집합
- '문자열'
- "문자열"
- \`문자열`
- 문자열은 변경 불가능한 값이다. (immutable value)

## 6-3. 템플릿 리터럴

- ES6부터 도입된 새로운 문자열 표기법
- 백틱을 사용하여 표현

### 1. 멀티 라인 문자열
일반 문자열 내에서 공백 등을 표현하는 방식을 사용하려면 아래와 같은 이스케이프 시퀀스를 사용한다. 
- '\n' : 개행
- \\' : 따옴표

- 일반 문자열과 다르게 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용된다. 
- 공백도 있는 그대로 적용된다. 

### 2. 표현식 삽입

- ${} 안에 표현식을 삽입한다.
- 표현식 삽입은 반드시 템플릿 리터럴

> 템플릿 리터럴이라는 용어에 대해서 처음 알수 있었다. 무심코 사용하는 것들의 용어와 정의를 기억해두자.

### 3. 태그드 템플릿

> 설명이 없어서 직접 찾아봤다.

- 템플릿 리터럴의 발전된 형태로써, 함수 형태로 사용할 수 있다.
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals
- https://mygumi.tistory.com/395

```javascript
const Button = styled.a`
  display: inline-block;
  border-radius: 3px;

  ${props => props.primary && css`
    background: white;
    color: black;
  `}
`
```
우리가 스타일드 컴포넌트에서 사용하는 이 방식도 사실 태그드 템플릿이다. 

```javascript
test.each`
  a    | b    | expected
  ${1} | ${1} | ${2}
  ${1} | ${2} | ${3}
  ${2} | ${1} | ${3}
`('returns $expected when $a is added $b', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```
jest에서 each 메서드도 마찬가지다.

## 6-4. 불리언 타입

- true / false

## 6-5. undefined

- 그 자체로 유일한 타입
- 변수를 선언하고 값을 할당하지 않는 경우 반환됨
- 개발자가 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용 => 권장하지 않음
- 의도적으로 값이 없는 것을 명시하고 싶다면 null을 사용

## 6-6. null

- 그 자체로 유일한 타입
- 값이 없는 것을 의도적으로 명시할 때 사용
- 이전에 값이 있었다가 null을 할당했다면, GC는 이 값을 나중에 지울 것임.
- 함수가 유효한 값을 반환할 수 없는 경우 null을 반환하기도 한다. => html case

## 6-7. 심벌 타입

- ES6에서 추가된 타입
- 변경 불가능한 원시 타입의 값
- 무조건 Symbol 생성자로 생성
- 다른 값과 절대 중복되지 않는다. 

## 6-8. 객체 타입

앞선 타입들이 원시타입이라면 나머지는 모두 객체 타입이다.
- 객체 타입에 대한 자세한 내용은 이후 챕터에서...

## 6-9. 데이터 타입의 필요성

### 1. 데이터 타입에 의한 메모리 공간의 확보와 참조
- 자바스크립트 엔진은 값의 종류에 따라 메모리 공간을 확보한다. 
- 데이터 타입에 따라 메모리 공간의 크기가 달라진다. 
- 읽어들일 때도 타입에 따라 읽어들이는 단위가 달라지기 때문에 타입이 필요하다.

- 심벌 테이블 : 컴파일러 또는 인터프리터가 다음과 같은 자료구조 형태로 관리한다.
```
{
  식별자 : {
    메모리주소 : 0x1233,
    데이터타입 : number,
    스코프 : global,
  }
}
```

### 2. 데이터 타입에 의한 값의 해석
- 2진수로 저장된 값을 데이터 타입에 따라 해석한다. 
- 같은 0100 0001이라도 타입에 따라 숫자 65, 문자 A로 해석될 수 있다.

## 6-10. 동적 타이핑

### 1. 동적 타입 언어와 정적 타입언어
- 정적 타입 언어
  - 변수 선언 시 타입을 함께 선언 (명시적 타입선언)
  - 컴파일 시점에 타입 체크 수행
  - 타입 체크를 통과하지 못하면 프로그램 실행자체를 막아버린다. 
- 동적 타입 언어 : 변수 선언 시 타입을 선언하지 않고 자유롭게 데이터 타입의 값을 할당할 수 있다.
  - 타입을 할당에 의해 결정 -> 타입 추론

> null을 typeof하면 object가 나온다.

### 2. 동적 타입 언어와 변수

변수의 값이 변경될 수 있기 때문에 다음 사항들을 지켜야한다.

- 동적 타입언어는 유연성은 높지만, 신뢰성은 떨어진다.
- 변수의 유효범위를 좁게 만들어야한다. => 전역변수 지양
- 상수 사용
- 변수의 목적과 의미를 파악할 수 있는 네이밍


> 데이터타입이 가진 의미와 의도를 잘 기억하는게 중요한 챕터였음.
왜 타입이 존재하는지도 알 수 있었던 챕터.

---
---
# 7. 연산자

- 연산자 : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산등을 수행하여 하나의 값을 만든다.
> 표현식(값으로 평가될 수 있어야함) 연산자 => (새로운) 값

## 7-1. 산술 연산자
- 수학적 계산을 수행해 새로운 숫자값을 만든다.
- 산술 연산이 불가한 경우, NaN을 반환한다.

### 1. 이항 산술 연산자
- **2개의 피연산자**를 산술 연산하여 숫자 값을 만든다. 
- side effect가 없이, 언제나 새로운 값을 만든다. 

|이항 산술 연산자|
|:---:|
|+|
|-|
|*|
|/|
|%|

### 2. 단항 산술 연산자
- **1개의 피연산자**를 산술 연산하여 숫자 값을 만든다.

|단항 산술 연산자||
|:---:|:---:|
|++|증가|
|--|감소|
|+|숫자 타입으로 변환하여 반환, 숫자는 아무런 변화 없음|
|-|양수를 음수로, 음수는 양수로|

- 증가/감소 연산자는 부수효과가 있다.
  - 전위 증가 : 먼저 증가시키고 다른 연산 수행 (++X)
  - 후위 증가 : 다른 연산 수행 후 증가 (X++)

> 부수효과가 있다 / 없다?

> 할당 시에는 전위 증가가 더 직관적인 코드인 것 같다.

- 숫자가 아닌 타입에 + 단항연산자를 사용하면 숫자 타입으로 변환된다.
- -true => -1
- 부수효과가 없기 때문에 직접적으로 값이 바뀌진 않는다. 

### 3. 문자열 연결 연산자
- \+ 연산자중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 
- 문자열 + 숫자 = 문자열

> 프로덕션 단계에서 문자열 + 문자열 병합을 사용하는 것은 안티 패턴일까?

- 개인적으론, 암묵적 타입 변환이 이뤄질 수 있기 때문에 좋지 않다고 보지만 단언할 수 있는 경우 사용해도 괜찮다고 생각한다. 

## 7-2. 할당 연산자

|할당 연산자||
|:---:|:---:|
|=||
|+=||
|-=||
|*=||
|/=||
|%=||

> 할당연산자 사용에 관한 의견?

```javascript
  counter += 1

  // vs

  counter = counter + 1;
```

- 간단 숫자정도는 개인적으로 많이 사용하는 편
- 직관적이지 않는다고 느껴질 때는 풀어서 쓰는게 더 낫다고 생각
- 나머지 할당연산자는 잘 써본 기억이 없음 
- 주로 더하기/빼기 할당연산자 위주 사용

## 7-3. 비교 연산자

### 1. 동등/일치 비교 연산자

|비교 연산자||
|:---:|:---:|
|==|동등 비교|
|===|일치 비교|
|!=|부동등 비교|
|!==|불일치 비교|

- 동등 비교는 사용하지 않는 편을 권장

NaN은 자기 자신과 일치 하지 않는 유일한 값이다. 
- `Number.isNaN()`을 통해 NaN여부를 확인


정말 엄격한 일치비교를 원한다면 `Object.is()`메서드를 사용한다.


### 2. 대소 관계 비교 연산자
|대소 관계 비교 연산자||
|:---:|:---:|
|>||
|<||
|>=||
|<=||


## 7-4. 삼항 조건 연산자

조건식 ? true일 때 값 : false 일 때 값

### if ... else문과의 차이
- if else 문은 값처럼 사용할 수 없다.

## 7-5. 논리 연산자

|논리 연산자||
|:---:|:---:|
|\|\||논리합|
|&&|논리곱|
|!|부정|

- 부정연산은 항상 불리언 값을 반환한다. 
- 논리곱이나 논리합은 2개의 피연산자 중 어느 한쪽으로 평가된다. 

## 7-6. 쉼표 연산자

쉼표를 통해 차례차례 피연산자를 평가하고 평가가 끝나면 **마지막 피연산자의 평가결과를 반환**한다.

## 7-7. 그룹 연산자

소괄호로 먼저 평가하길 원하는 연산자 표현식을 감싼다.


## 7-8. typeof 연산자

데이터 타입을 문자열로 반환한다. 

typeof null은 object가 나오는데 이것은 자바스크립트 버그이다.
- null의 경우에는 일치 연산자를 사용하여 타입을 검사한다. 

선언하지 않은 식별자를 typeof 연산하게 되면 undefined가 반환된다.

## 7-9. 지수 연산자

- ES7에서 도입
- 밑 ** 지수
- 2 ** 2 // 2의 2승
- Math.pow(밑, 지수)
- (-5) ** 2 : 음수의 경우 괄호로 묶어야함

## 7-10. 그 외의 연산자

|연산자||
|:---:|:---:|
|?.| 옵셔널 체이닝|
|??| null 병합|
|delete| 프로퍼티 삭제|
|new| 인스턴스 생성|
|instanceOf| 인스턴스인지 판별 |
|in| 프로퍼티 존재 확인 |

## 7-11. 연산자의 부수효과

- 할당 연산자
- 증가/감소 연산자
- delete 연산자

## 7-12. 연산자 우선 순위

연산자가 실행되는 순서.
할당 연산은 거의 마지막에 실행되며 삼항연산자도 우선순위가 낮다.
증가 감소 연산자는 상대적으로 높으며,
후위가 전위보다 높다.

## 7-13. 연산자 결합 순서

연산자의 어느 쪽부터 평가할지 순서를 의미
- 우항에서 좌항으로 평가 하는 것들은 할당연산, 증가/감소, typeof, 삼항연산자 등이 있다.

> 특이 케이스들을 잘 기억해두는 것이 중요한 챕터였음.