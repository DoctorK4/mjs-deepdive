# 8. 제어문

제어문 : 조건에 따라 코드 블록을 실행하거나, 로직을 반복 실행할 때 사용한다.

제어문의 단점
- 코드의 가독성을 해침 : 순차적을 진행하는 코드가 아니라 직관적이지 않음.

> **<예상질문>**
> <br/> Q. 제어문의 가독성을 해치는 단점을 극복하기 위한 방법은 ?
> <br/> A. forEach, reduce, map, filter 와 같은 고차함수 사용을 통해 복잡성을 억제한다. 

## 8-1. 블록문

**블록문**
1. 0개 이상의 문을 중괄호로 묶은 것, 코드 블록, 또는 블록이라고도 한다.
2. 단독사용 가능하나 주로 제어문, 함수 사용시 사용
3. 블록문의 끝에는 세미콜론을 붙이지 않는다. 

## 8-2. 조건문

조건문 : 주어진 조건식의 평가 결과에 따라 코드블록의 실행을 결정하는 문

조건식 : 불리언 값으로 평가될 수 있는 표현식

### 8.2.1 if...else문
- 논리적 참 또는 거짓에 따라 실행할 코드 블록이 결정된다. 
- true일 경우 if 블록이, false일 경우 else 블록이 실행된다.
- 조건을 늘리고 싶다면 else if 를 사용하면 된다. if와 else와 다르게 여러번 사용할 수 있다.

- 조건식이 불리언 값으로 평가되지 않으면, 자바스크립트 엔진에 의해 암묵적 타입 변환이 이뤄져 불리언 값으로 평가된다.

> **깨달은점**
> <br/> 관습적으로 사용하던 if (){} else {} 문법의 의미를 알 수 있었다.  

코드 블록 내 문이 하나라면 중괄호를 생략할 수 있음.

### 삼항연산자로 바꿀 수 있다
<예시 1>
```javascript
const x = 2;
let result = x % 2 ? '홀수' : '짝수';
```
<예시 2 : 삼항연산자의 중첩>
```javascript
const kind = num ? (num > 0 ? '양수' : '음수') : '영';
```

### 8.2.2 switch 문
```javascript
switch (표현식) {
  // => 표현식과 일치하는 case로 이동
  case 표현식 1:
    실행할 로직;
    break
  case 표현식 2:
    실행할 로직;
    break
  default:
    일치하는 case가 없을 때 실행할 문;
}
```
break문이 없다면 
- 모든 case문과 default문을 실행한다 => fall through

> **<예상질문>**
> <br/> switch 문의 사용법에 대해 설명해주세요

## 8-3 반복문

### 8.3.1 for 문

```javascript
for (변수선언문; 조건식; 증감식) {
  코드블록
}
```

**for문 flow**
- 변수선언문은 한번만 실행된다.
- 조건식이 true이면 코드블록이 실행된다.
- 코드블록이 실행되고 증감식이 실행된다. 
- 증감식이 실행되고 다시 조건식 평가가 이뤄진다.
- 어떤 식도 선언하지 않으면 무한루프가 된다.
- for문 내 for문을 중첩활용할 수 있다. 

### 8.3.2 while문
- 반복횟수가 불명확할 때 주로 사용된다.
- 주어진 조건식이 차이면 코드블록을 실행하고, 거짓이면 종료한다.

### 8.3.3 do...while문
- 코드블록을 한번 실행하고 조건식의 평가에 따라 반복한다. 
- 따라서 무조건 한번은 코드블록이 실행된다.

```javascript
let count = 1;

do {
  count++
} while (count < 3;)
```

## 8-4 break문
- break문은 반복문, 레이블문, switch문의 코드블록을 탈출한다.
- 그외 코드블록에서 사용하면 SyntaxError를 발생시킨다.

### 레이블문이란?
- 식별자가 붙은 문을 의미한다. 

```javascript
outer : for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if ( i + j === 3) break outer;
    console.log(`inner ${i} ${j}`)
  }
}
```
레이블 문의 코드블록을 나오려면 break 뒤에 outer를 써준 것처럼 레이블문의 식별자를 함께 적어줘야한다. 

## 8-5 continue문

- 반복문의 코드블록 실행을 현시점에서 중단하고, 반복문의 증감식으로 실행흐름을 이동시킨다.
- 반복문을 탈출하지는 않는다. 



# 9. 타입 변환과 단축 평가

## 9-1. 타입 변환이란? 

명시적 타입 변환 (타입 캐스팅)
- 개발자가 의도적으로 값의 타입을 변환하는 것

암묵적 타입 변환 (타입 강제 변환)
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되는 것
- 기존 값을 변경하는 것이 아니라, 기존 값을 사용해 새로운 타입의 원시값을 생성하는 것

## 9-2. 암묵적 타입 변환

표현식을 평가할 때 문맥에 부합하지 않은 상황이 발생해도, 자바스크립트 엔진은 암묵적 타입 변환을 통해 표현식을 평가하여 가급적 에러를 일으키지 않는 방향으로 작동한다. 

### 9.2.1 문자열 타입으로 변환

```javascript
1 + '2' = 12 // 3(x)
```
- \+ 연산 중 피연산자 중 하나가 문자열이라면 문자열 연결 연산자로 동작한다.
- 문자열이 아닌 피연산자를 문자열로 암묵적 타입변환 한다.

**헷갈리는 케이스들 정리**
```javascript
undefined + "" // "undefined";

null + "" // "null"

({}) + "" // "[object Object]"

(Symbol()) + "" // TypeError

```

> **<퀴즈>**
> <br/> 문자열 과 숫자를 더하면 어떤 일이 일어나는가? 


### 9.2.2 숫자 타입으로 변환

- 산술 연산에서 숫자가 아닌 피연산자를 숫자로 암묵적 타입 변환한다.
- 숫자 타입으로 변환할 수 없는 경우에는 NaN을 반환한다.

**헷갈리는 케이스들 정리**
```javascript
+undefined // NaN

+[] // 0

+{} // NaN
```

> **<퀴즈>**
> <br/> 문자열과 숫자를 곱하면 어떤 일이 일어나는가? 
> <br/> 문자열이 일반 문자열 이라면 NaN, 숫자 형태의 문자열이라면 타입변환되어 연산값이 나온다. 


### 9.2.3 불리언 타입으로 변환
- 조건식 평가에서 피연산자가 불리언 타입이 아닌 경우, 암묵적 타입 변환을 통해 불리언으로 평가하여 조건식을 실행 혹은 건너뛴다. 
- Truthy한 값 => True로 평가
- Falsy한 값 => False로 평가
  - false
  - undefined
  - null
  - 0, -0
  - NaN
  - '' (빈 문자열)

> **<토론주제>**
> <br/> 조건식 사용 시 암묵적 타입 변환을 활용한 코드 작성 찬성 vs 반대

예시
```javascript
if (isLogin) {
  ...
}

// vs

if (isLogin === true) {
  ...
}
```

## 9-3. 명시적 타입 변환

### 9.3.1 문자열 타입으로 변환
1. String() 생성자 함수
2. ().toString() 메서드
3. 문자열 연결 연산자 (+ '')

### 9.3.2 숫자 타입으로 변환  
1. Number()
2. parseInt, parseFloat() (문자열만)
3. + 단항 산술 연산자
4. * 산술 연산자 이용

### 9.3.3 불리언 타입으로 변환 
1. Boolean() 생성자 함수
2. !!

## 9-4. 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가
- 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

#### &&
- 둘다 true일 경우 true 반환
- 두번째 평가 결과를 반환

#### ||
- 둘 중 하나면 true여도 true
- 논리 연산의 결과를 결정한 값을 반환

논리합, 논리곱 연산자는 논리 연산의 결과를 결정하는 피연산자를 타입변환하지 않고 그대로 반환 
- => **단축 평가** : 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략

#### 활용 예시
1. if문 대체
```javascript
let done = true;

.
.
.

c_message = done &&  '완료'; // dong이 true라면 '완료'가 할당;

n_message = done || '미완료' // done이 false라면 '미완료'가 할당;
```

2. 객체의 프로퍼티를 참조할 때 null, undefined를 대비한 코드
```javascript
//el is Object or null/undefined

let value = el && el.value;
```

3. 함수 매개변수에 기본값 설정
```javascript
function foo(str) {
  str = str || '';
  return str.length
}
```

> => ES6의 기본값 설정 생긴 이후로는 잘 안쓰는듯하다. 

### 9.4.2 옵셔널 체이닝 연산자
- ?.
- ES11에서 도입되었음
- 좌항이 null 또는 undefined인 경우 undefined를 반환하고 
- 그렇지 않다면 우항의 프로퍼티 참조를 이어간다.

```javascript
//el is Object or null/undefined

let value = el?.value;

let value = el && el.value; // 과거) 논리곱을 활용하여 할당
```

### 9.4.3 null 병합 연산자
- ??
- ES11에서 도입되었음
- 좌항의 피연산자가 null 또는 undefined인 경우, 우항의 피연산자를 반환 
- 그렇지 않은 경우 좌항의 피연산자를 반환
- 기본값 설정 시 유리하다.

```javascript
// foo is value or null/undefined

let value = foo ?? 'default value';

let value = foo || 'default value'; // 과거) 논리합을 활용하여 할당

```

논리합을 통한 기본값 할당의 경우에는 falsy값인 경우들이 많아 null과 undefined만을 위한 연산이 되지 못해 문제가 있었다.

> **<예상질문>**
> <br/> 1. 옵셔널 체이닝 연산자 // nullish 에 대해 설명해주세요.
> <br/> 2. 사용해본 적 있나요? 사용해봤다면 언제 사용해봤나요?

# 10. 객체 리터럴

## 10-1. 객체란?
- 객체 : 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조
  - 객체는 변경 가능한 값
- 프로퍼티 : 객체의 상태를 나타내는 값(data)
  - key와 value로 구성
- 메서드 : 프로퍼티 값이 함수인 것

## 10-2. 객체 리터럴에 의한 객체 생성
- 리터럴 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법

## 10-3. 프로퍼티
- 객체는 프로퍼티의 집합
- 프로퍼티는 키와 값으로 구성되어있다.
- 프로퍼티 나열 시 쉼표로 구분한다. 
- 식별자 네이밍 규칙에 맞는 키는 따옴표를 생략할 수 있다. 
- 그렇지 않은 식별자는 반드시 따옴표르 사용해야 한다. 
- key를 동적 생성하는 표현식은 대괄호로 묶어야한다.

```javascript
const person = {
  firstName : 'dr',
  'last-name' : 'K', // 식별자 네이밍 규칙에 따르지 않는 값은 따옴표를 사용한다.
};

const message = {};
message[key] = 'world'; // 동적 할당하는 경우에는 대괄호 사용
```

- 숫자를 사용하면 따옴표는 붙이지 않아도 되지만 내부적으로는 문자열로 변환된다. 
=> 안티패턴이라는 말도 많이 있음
- 예약어를 사용해도 적용은 된다 => but, 안티패턴
- 이미 존재하는 프로퍼티 키를 사용하면 나중에 선언한 것이 덮어쓴다. 

## 10-4. 메서드

- 함수는 값으로 취급될 수 있기 때문에 프로퍼티 값으로 사용될 수 있다. 
- 일반함수와 구분하기 위해 메서드라 부른다.
- this 키워드는 객체 자신을 가르키는 참조변수이다.

## 10-5. 프로퍼티 접근

- 마침표 표기법
- 대괄호표기법 : 반드시 따옴표로 감싼 문자열 키이어야한다.

> **예상질문**
> <br /> Q. 객체에 존재하지 않는 프로퍼티에 접근하면 어떤 일이 발생하는가?


## 10-6. 프로퍼티 값 갱신

## 10-7. 프로퍼티 동적 생성

## 10-8. 프로퍼티 삭제
- delete 연산자 사용
- 존재하지 않는 프로퍼티를 삭제하면 에러없이 무시된다. 

## 10-9. ES6에서 추가된 객체 리터럴의 확장 기능

### 10.9.1 프로퍼티 축약표현
- 변수이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.
```javascript
const obj = {
  x: x,
  y: y,
};

// 축약표현
const obj = {
  x,
  y
};
```
### 10.9.2 계산된 프로퍼티 이름
- 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 동적으로 프로퍼티 키를 생성할 수 있다. 
- 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야한다.
- computed property name이라 한다.

### 10.9.3 메서드 축약표현
- 메서드를 정의할 때 function을 생략하고 축약하여 표현할 수 있다.
- _축약표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다._

```javascript
let obj = {
  sayHi: function() {
    console.log('hi');
  }
};

// 축약표현
let obj = {
  sayHi() {
    console.log('hi');
  }
};
```

# 11. 원시 값과 객체의 비교

- 원시타입의 값
  - 변경 불가능한 값
  - 확보된 메모리 공간에 실제 값이 저장된다.
  - 값에 의한 전달
- 객체(참조)타입의 값
  - 변경 가능한 값
  - 확보된 메모리 공간에 참조 값이 저장된다.
  - 참조에 의한 전달

## 11-1 원시값

### 11.1.1 변경 불가능한 값
- 변경이 불가능한 것은 변수가 아니라 값에 대한 진술
- 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다. 

> **<퀴즈>**
> <br/> 1. const 로 선언한 객체의 내용을 변경하고 싶다면 let으로 코드를 변경해야한다. (O, X)
> <br/> 2. 원시타입 불변성의 이유로, 변수는 변경될 수 없다. (O, X)
> <br/> 3. 변수에 변수값을 재할당하면 메모리 주소값이 바뀐다. (O, X)

### 11.1.2 문자열과 불변성
- 문자열은 변경 불가능한 값이다. 
- 새로운 문자열 값을 할당하고 싶다면 새로운 문자열을 새 메모리 공간에 할당하고 변수를 해당 메모리공간 주소로 변경한다.

> **<퀴즈>**
> <br/> 1. 문자열은 유사배열 객체이다. (O, X)
> <br/> 2. 유사배열의 특징 2가지를 말해주세요.

### 11.1.3 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시값이 복사되어 전달된다.
- 하지만 각 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다. 

>  **<퀴즈>**
> <br/> 1. 변수에 원시 값을 갖는 변수를 할당하면 그 변수 값은 할당하는 변수의 메모리 주소와 동일하다. (O, X)

## 11-2 객체

### 11.2.1 변경 가능한 값
- 객체를 할당한 변수에는 객체 데이터가 저장되어있는 메모리 주소 그 자체를 저장하고 있다.
- 재할당 없이 객체의 프로퍼티를 추가/수정/삭제 할 수 있다.

#### 객체를 불변값으로 하지 않는 이유?
1. 크기가 매우 클 가능성이 있다.
2. 원시값과 다르게 크기가 들쭉날쭉하다.
3. deep copy하는 비용이 크다.

- 참조값을 통해 객체를 할당하기 때문에, 여러개의 식별자가 하나의 객체를 가리키는 경우도 있다.

#### 얕은 복사와 깊은 복사

- 얕은 복사
  - 한단계 까지만 복사하는 것
  - 스프레드 문법
  - (다른 정의) 객체를 할당한 변수를 다른 변수에 할당하는 것

- 깊은 복사
  - 객체에 중첩되어 있는 개체까지 모두 복사하는 것
  - lodash `cloneDeep` 메서드
  - (다른 정의) 원시값을 다른 변수에 할당하는 것

> **<예상면접질문>**
> <br/> 얕은 복사와 깊은 복사의 차이와 구현 방법에 대해 이야기해주세요.


### 11.2.2 참조에 의한 전달
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달되는 것
- 두 개의 식별자가 하나의 객체를 공유
- 원본 또는 사본에서 객체를 변경하면 그 영향을 공유한다.
- 값에 의한 전달이나, 참조에 의한 전달 모두 메모리 공간에 저장되어 있는 값을 공유한다는 점에서 같다.
  - 다만 메모리 공간에 원시 값이 저장되어있느냐, 메모리 주소 참조값이냐의 차이일 뿐. 
