# 20장 strict mode

## 20-1. strict mode란? 
- 자바스크립트 문법을 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 문제를 일으킬 수 있는 코드에 대해 명시적 에러를 발생시키는 모드.
- ES5에서부터 추가되었음
- ES6 클래스와 모듈은 기본적으로 strict mode가 적용된다.
- 암묵적 전역(implicit global): 자바스크립트 엔진이 선언되지 않은 변수를 전역 객체에 동적으로 변수 프로퍼티를 생성하여 해석한다. 

## 20-2. strict mode의 적용
- 전역 선두 혹은 함수 선두에서 `'use strict';`를 추가한다.
- 코드 선두에 제대로 위치시키지 않으면 엄격 모드가 동작하지 않는다.

## 20-3. 전역에 strict mode를 적용하는 것은 피하자
- 전역에 적용한 strict mode는 스크립트 단위로 적용된다.
- 하지만 외부 서드파티 라이브러리를 사용하는 경우 non-strict mode인 경우도 있기 때문에 전역에 stict mode를 적용하는 것은 바람직하지 않을 수 있음
- 권장방법 : 즉시 실행 함수의 선두에 strict mode를 적용

## 20-4. 함수 단위로 strict mode를 적용하는 것도 피하자
- 함수단위로 적용하게 되면 일관성있게 적용하지 않으면 문제가 생길 수 있음
- 그렇다고 일일이 함수마다 적용하는 것도 번거로움
- 또 함수 외부 컨텍스트에 strict mode를 적용하지 않는다면 문제 발생 우려가 있음
- 권장방법 : 마찬가지로 즉시 실행함수로 감싸 스크립트 단위로 적용

## 20-5. strict mode가 발생시키는 에러

### 20.5.1 암묵적 전역
- 선언하지 않은 변수 => ReferenceError 발생

### 20.5.2 변수, 함수, 매개변수의 삭제
- delete연산자로 변수, 함수, 매개변수 삭제 시 => SyntaxError 발생

### 20.5.3 매개변수 이름의 중복
- 중복된 매개변수 이름 사용 => SyntaxError 발생

### 20.5.4 with문의 사용
- with 문 사용시 => SyntaxError 발생
- with 문을 사용하면 코드가 간단해지지만 성능과 가독성이 나빠진다.

## 20-6. strict mode 적용에 의한 변화

### 20.6.1 일반 함수의 this
- 함수를 일반 함수로 호출하면 this가 undefined에 바인딩 된다.

### 20.6.2 arguments 객체
- 전달된 인수를 재할당하여 변경해도, arguments 객체에 반영되지 않는다.

# 21장 빌트인 객체

## 21-1. 자바스크립트 객체의 분류
1. 표준 빌트인 객체
 - ECMA Script에 정의된 객체
 - 어플리케이션 전역에 공통 기능 제공
 - 자바스크립트 실행환경에 관계없이 사용할 수 있다. 
2. 호스트 객체
  - 자바스크립트 실행환경에서 추가로 제공하는 객체
  - 브라우저 환경 : Web API
  - Node js : Node js 고유 API
3. 사용자 정의 객체
  - 사용자가 직접 정의한 객체

## 21-2. 표준 빌트인 객체
- 40여개의 표준 빌트인 객체
  - 생성자 함수 객체인 표준 빌트인 객체 => 프로토타입 메서드와 정적 메서드 제공
  - 생성자 함수 객체가 아닌 표준 빌트인 객체 => 정적 메서드만 제공

### ex)  `Number`
  - 인스턴스 생성 : new Number(1.5)
  - 프로토타입 메서드 : num.toFixed()
  - 정적 메서드 : Number.isInteger(1)

## 21-3. 원시값과 래퍼 객체
- 원시값은 객체가 아닌데도 프로퍼티나 메서드를 갖는 것처럼 동작할 때가 있다.
- 이 경우 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문이다.
- 원시값에 대해 암묵적으로 연관된 객체를 생성하여 프로퍼티, 메서드에 접근 후 다시 원시값으로 돌린다.
- 이때 임시로 생성되는 객체를 래퍼 객체라고 한다.
- 원시값으로 돌아간 뒤에는 래퍼 객체는 가비지 컬렉션의 대상이 된다.
- 단, null과 undefined는 래퍼 객체를 생성하지 않는다. 객체처럼 사용하고자 하면 에러가 발생한다.

## 21-4. 전역 객체
- 어떤 객체보다도 먼저 생성되는 특수한 객체
- 어떤 객체에도 속하지 않는 최상위 객체
- 브라우저 환경에서는 window, Node.js 환경에서는 global이 전역객체를 가리킨다.

> globalThis : 전역 객체를 가리키는 다양한 식별자를 통일한 식별자이다. ES11에서 도입되었다. (표준)

**전역 객체의 구성**
- 표준 빌트인 객체
- 호스트 객체
- var키워드로 선언한 전역 변수
  - let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 이들은 보이지 않는 개념적인 블록 내에 존재한다.
- 암묵적 전역 (선언하지 않은 변수에 값을 할당)
- 전역 함수

**전역 객체의 특성**
- 전역 객체는 모든 빌트인 객체의 최상위 객체이다. 그러나 프로토타입 상속 관계상의 최상위 객체라는 뜻은 아니다.
- 개발자가 의도적으로 생성할 수 없다.
- 전역 객체의 프로퍼티를 참조할때 window 또는 global을 생략할 수 있다.
- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 분리되어있는 코드라고 할지라도.

### 21.4.1 빌트인 전역 프로퍼티
- 전역 객체의 프로퍼티
- 애플리케이션 전역에서 사용하는 값을 제공한다. 

#### Infintiy
- 무한대를 나타내는 숫자값

#### NaN
- Not a Number 을 나타내는 숫자값 NaN

#### undefined
- 원시값 undefined

### 21.4.2 빌트인 전역 함수

#### eval
- 인수로 자바스크립트 코드를 나타내는 문자열을 받는다.
- 인수가 표현식이라면 런타임에 평가하여 값을 생성한다.
- 표현식이 아닌 문이라면 문자열 코드를 런타임에 실행한다.
- 여러 개의 문이라면, 모든 문을 실행한다.
- 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.
- 단, strict mode에선 기존의 스코프를 수정하지 않고 eval함수 자신만의 스코프를 생성한다.
- let, const 선언 키워드를 사용하면 암묵적으로 strict mode가 적용된다.

  > eval 함수 사용을 지양해야한다.
  > - 이유 1. 자바스크립트 엔진이 최적화하지 않은 코드를 실행하는 것이며, 이는 성능에 영향을 미칠 수 있다.
  > - 이유 2. 보안에 매우 취약하다.

#### isFinite
- 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.
- 숫자가 아니라면 숫자로 변환 후 검사를 수행한다.
- NaN으로 평가되면 false를 반환한다.

#### isNaN
- NaN인지 검사하여 불리언 타입으로 반환한다.
- 숫자가 아니라면 숫자로 변환 후 검사를 수행한다.
- undefined가 인자로 들어오면, true를 반환한다.
- 빈 객체가 들어오면, true를 반환한다.

#### parseFloat
- 전달받은 문자열 인수를 부동 소수점 숫자, 실수로 해석하여 반환한다.
- 첫번째 문자열을 숫자로 변화할 수 없다면, NaN을 반환한다.
- 공백으로 구분된 문자열은 첫번째 문자열만 변환된다.
- 앞뒤 공백은 무시된다.

#### parseInt
- 전달받은 문자열 인수를 정수로 해석하여 반환한다.
- 문자열이 아니라면 문자열로 변환한다음, 정수로 해석하여 반환한다.
- 두번째 인수로 진법을 나타내는 기수를 전달할 수 있다. 
- 반환값은 언제나 10진수이다.
- 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을때는 `Number.prototype.toString()` 메서드를 사용한다.
- 16진수 리터럴 형태로 문자열이 들어오면 16진수로 해석하여 10진수 정수로 반환한다.
- 첫번째 문자가 해당지수의 숫자로 변환될 수 없다면 NaN을 반환한다.
- 두번째 문자부터 숫자가 아닌 문자와 마주치면 이후 계속되는 문자들은 무시되고, 해석된 정수값만 반환된다. 
- 앞뒤 공백은 무시된다.

#### encodeURI / decodeURI
- 인코딩 : URI의 문자를 이스케이프 처리하는 것
- 이스케이프 처리 : 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
- encodeURI : URI를 인수로 받아 이스케이프 처리를 위해 인코딩한 값을 반환한다.
- decodeURI : 인코딩된 URI를 받아 이스케이프 처리 이전으로 디코딩한다.
- 쿼리 스트링 구분자로 사용되는 =, ? &은 인코딩하지 않는다.(완전한 URI 전체로 간주하기 때문)

#### encodeURIComponent / decodeURIComponent
- URI 구성요소를 인수로 받아 인코딩/디코딩한다.
- 쿼리 스트링 구분자로 사용되는 =, ? &까지 인코딩한다.

### 21.4.3 암묵적 전역
- 암묵적 전역으로 해석된 식별자는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 
- 하지만 이 식별자는 변수가 아니다. 변수가 아니므로 변수 호이스팅이 일어나지 않는다.
- 전역 객체의 프로퍼티 이기에 delete 연산자로 삭제할 수 있다. 

# 22장 this

## 22-1. this 키워드
- 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면, 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야한다.
- 객체 리터럴로 생성한 객체의 경우 재귀적으로 참조할 수 있다.
- 하지만 생성자 함수 방식으로 인스턴스를 생성하는 경우 자신이 생성할 인스턴스를 가리키는 식별자가 없다.
- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
- this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.
- this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

> **<this 바인딩>** <br/>
> 식별자와 값을 연결하는 과정을 바인딩이라 한다. this 바인딩이란 this와 this가 가리킬 객체를 바인딩하는 것이다.

#### 객체 리터럴에서의 this
- 메서드를 호출한 객체를 가리킨다.

#### 생성자 함수 내부의 this
- 생성할 인스턴스

#### strict mode가 적용된 일반 함수 내부의 this
- this는 자기 참조를 위한 변수이므로 외부에서는 의미가 없음
- strict mode에서는 일반함수의 this가 undefined로 바인딩됨.

## 22-2.함수 호출 방식과 this 바인딩
- this 바인딩은 함수 호출방식에 따라 동적으로 결정된다.
- 동일한 함수도 다양한 방식으로 호출될 수 있다.
  - 일반 함수 호출
  - 메서드 호출
  - 생성자 함수 호출
  - Function.prototype.apply/call/bind 메서드에 의한 간접 호출

### 22.2.1 일반 함수 호출
- this에는 전역 객체가 바인딩된다.
- 일반함수로 호출된 모든 함수 (콜백, 중첩 등 포함) 내부의 this는 전역 객체가 바인딩된다.
- 문제의식 ! : 메서드 내에서 정의한 중첩함수 혹은 콜백함수가 this 바인딩이 전역객체로 되는 것은 불편한 일
  - 헬퍼 함수의 역할을 하는데, this가 일치하지 않는 것은 헬퍼 함수로서의 역할을 하기 어렵게 함
  - => 이를 해결하기 위한 방안
    - that 활용
    - 명시적 바인딩 : Function.prototype.apply/call/bind 메서드에 의한 간접 호출
    - 화살표 함수 사용

### 22.2.2 메서드 호출
- 메서드의 this는 메서드를 호출할 때 메서드 이름 앞의 마침표 연산자 앞에 기술된 객체가 바인딩 된다.
- 메서드는 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 함수 객체이다.
- 프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩 된다. 

### 22.2.3 생성자 함수 호출
- 생성자 함수의 this에는 생성될 인스턴스가 바인딩된다.
- 생성자 함수는 일반함수처럼 호출될 수 있는데, 이 경우 마찬가지로 this는 전역객체를 가리킨다.

### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출
- apply, call, bind 메서드는 Function.prototype의 메서드이다. 이들 메서드는 모든 함수가 상속받아 사용할 수 있다.
- apply : (this로 사용할 객체, 함수에게 전달할 인수리스트의 배열, 혹은 유사배열 객체) => 호출된 함수의 반환값
- call : (this로 사용할 객체, 함수에게 전달할 인수리스트) => 호출된 함수의 반환값
  - apply/call 모두 함수를 호출하는 역할
  - 함수의 인수를 apply는 배열에, call은 리스트 형식으로 전달하는 차이이다. 
  - Array.prototype.~ 와 같은 배열 메서드도 apply와 call을 통해 사용가능하다. 
- bind의 경우, 함수를 호출하진 않고, this 바인딩이 새롭게 교체된 함수를 리턴한다.
  - bind 메서드는 메서드 내부 중첩 함수 혹은 콜백 함수의 this 불일치 문제를 해결하는데 자주 사용된다.

# 23장 실행 컨텍스트

## 23-1. 소스코드의 타입
- ECMA Script는 소스코드를 4가지 타입으로 구분한다. 
- 각 타입은 실행 컨텍스트를 생성한다.

### 전역 코드
- 전역 코드는 전역 변수를 관리하기 위한 전역 스코프를 생성한다.
- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야한다.
- 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.

### 함수 코드
- 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다.
- 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
- 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.

### eval 코드
- strict mode에서 독자적인 스코프를 생성한다. 
- eval 코드가 평가되면 eval 실행 컨텍스트가 생서된다. 

### 모듈 코드
- 모듈별로 독립적인 모듈 스코프를 생성한다.
- 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다. 

## 23-2. 소스코드의 평가와 실행
- 모든 소스코드는 평가와 실행단계로 나눠 처리된다.
- 평가 과정 
  - 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 변수나 함수 식별자를 키로 하여 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.
- 실행 단계
  - 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다.(런타임)
  - 실행에 필요한 정보는 스코프에서 검색해서 취득한다.
  - 실행 결과는 다시 스코프에 등록되나. 

## 23-3. 실행 컨텍스트의 역할

### 1. 전역 코드의 평가
- 실행을 위한 준비를 하는 단계
- 선언문만 먼저 시행한다.
- 전역 스코프에 식별자를 등록하고 초기화 등을 한다.
- var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티, 메서드가 된다.

### 2. 전역 코드의 실행
- 전역 코드가 순차적으로 실행된다. (런타임)
- 이때 변수에 값이 할당되고 함수가 호출된다.
- 함수가 호출되면 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.

### 3. 함수 코드의 평가
- 함수 코드를 실행하기 위한 준비를 한다.
- 매개변수와 지역 변수 선언문이 먼저 실행되고, 지역 스코프에 이들을 등록한다.
- arguments 객체가 생성되어 지역 스코프에 등록된다.
- this 바인딩도 결정된다.

### 4. 함수 코드의 실행
- 함수 코드가 순차적으로 실행된다. (런타임)
- 메서드 호출이 있다면 식별자를 스코프 체인을 통해 검색하여 실행한다.
- 함수 코드의 실행이 완료되었다면 전역 코드 실행을 이어간다. 

> 이처럼, 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값, 그리고 코드 실행순서 등이 실행 컨텍스트에 의해 관리되어야한다.

즉 실행 컨텍스트란, 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
- 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리한다.
- 스코프는 중첩 관계에 의해 스코프 체인을 형성하여 한다. 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.
- 현재 실행중인 코드의 실행 순서를 변경할 수 있어야하고, 다시 되돌아 갈수 있어야한다. 
- 렉시컬 환경 : 식별자와 스코프 관리
- 실행컨텍스트 스택 : 코드 실행 순서 관리

## 23-4. 실행 컨텍스트 스택
- 실행 컨텍스트는 stack 자료 구조로 관리된다.
- 코드의 실행 순서를 관리한다.
- 실행중인 실행 컨텍스트 (running execution context): 스택 최상단에 있는 실행 컨텍스트가 현재 실행중인 코드의 실행 컨텍스트다.

## 23-5. 렉시컬 환경
- 스코프와 식별자를 관리한다.
- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 렉시컬 환경은 2개의 컴포넌트로 구성된다.
  - 환경 레코드 : 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리한다.
  - 외부 렉시컬 환경에 대한 참조 : 상위 스코프를 가리킨다. 이 참조를 통해 스코프 체인을 구현한다.

## 23-6. 실행 컨텍스트의 생성과 식별자 검색 과정

### 23.6.1 전역 객체 생성
- 전역 코드가 평가하되기 이전에 생성된다. 
- 빌트인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체와 실행 환경에 따른 호스트 객체가 전역 객체에 추가된다.
- 전역 객체도 Object.prototype을 상속받는다.

### 23.6.2 전역 코드 평가
- 소스코드가 로드되면 전역 코드를 평가한다.

#### 전역 코드 평가 순서
- 전역 실행 컨텍스트 생성
- 전역 렉시컬 환경 생성
  - 전역 환경 레코드 생성
    - 객체 환경 레코드 생성
    - 선언적 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성
- 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다.

#### 2. 전역 렉시컬 환경 생성
- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.

#### 2.1 전역 환경 레코드 생성
- 전역 렉시컬 환경을 구성하는 컴포넌트 중 하나인 전역 환경 레코드를 생성한다.
- 전역 스코프, 전역 객체의 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 제공한다,.
- ES6부터 let, const 선언 전역 변수와 구분하고 관리하기 위해 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성하고 있다.
- 객체 환경 레코드 : var 키워드 선언 전역 변수, 함수선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리한다.
- 선언적 환경 레코드 : let, const 키워드로 선언한 전역 변수를 관리한다. 

#### 2.1.1 객체 환경 레코드 생성
- BindingObject라는 객체와 연결된다. 이는 전역 객체 생성단계에서 생성된 전역 객체이다.
- 전역 코드 평가 과정에서 var 키워드로 선언된 전역변수와 함수 선언문으로 정의된 전역 함수는 이 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
- var 키워드로 선언한 변수는, 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한다음, 값을 undefined로 초기화한다. 이로 인해 실행단계에서 변수 선언문 이전에도 참조할 수 있는 것이다.
- 함수 선언문으로 정의된 함수의 경우, 마찬가지로 BindingObject를 통해 전역 객체에 키로 등록하고, 생성된 함수 객체를 **즉시** 할당한다. 함수 선언문 이전에 함수를 호출할 수 있는 이유이다.

#### 2.1.2 선언적 환경 레코드 생성
- let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다. 이들은 전역객체의 프로퍼티가 되지 않는다.
- window.y와 같이 전역 객체의 프로퍼티로서 참조할 수 없다.
- const 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다. 
- 런타임에 실행 흐름이 변수선언문에 도달하기 전까지 일시적 사각지대에 빠지게 된다.

#### 2.2 this 바인딩
- 전역환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 
- 일반적으로 전역 객체가 바인딩된다.
- this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.

#### 2.3 외부 렉시컬 환경에 대한 참조 결정
- 전역 코드의 상위 스코프는 없으므로, 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 null이 할당된다.
- 전역 렉시컬 환경이 스코프 체인의 종점에 존재하는 이유이다.

### 23.6.3 전역 코드 실행 
- 코드를 실행하면서 식별자 결정단계를 거친다. 식별자를 검색할 때는 실행중인 실행컨텍스트에서 식별자를 검색하기 시작한다.
- 만약 실행 중인 실행컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 상위 스코프로 이동하여 식별자를 검색한다.
- 검색할 수 없는 경우 참조 에러를 발생시킨다. 

### 23.6.4 foo 함수 코드 평가
- 함수가 호출되면 전역 코드의 실행을 일시 중단하고 함수 내부로 코드의 제어권이 이동한다. 
- 그리곤 함수코드의 평가가 시작된다. 

#### 함수 코드의 평가 단계
- 함수 실행 컨텍스트 생성
- 함수 렉시컬 환경 생성
  - 함수 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

#### 1. 함수 실행 컨텍스트 생성
- 호출된 함수의 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시된다. 
- 스택의 최상위가 해당 함수의 실행 컨텍스트가 된다.

#### 2. 함수 렉시컬 환경 생성
- 함수 렉시컬 환경을 생성하고 함수 실행 컨텍스트에 바인딩한다.

#### 2.1 함수 환경 레코드 생성
- 함수 환경 레코드는 함수 렉시컬 환경을 구성하는 컴포넌트 중 하나이다. 
- 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

#### 2.2 this 바인딩
- [[ThisValue]] 내부 슬롯에 this가 바인딩된다. 

#### 2.3 외부 렉시컬 환경에 대한 참조 결정
- 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
- 함수 객체를 생성할 때 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 함수 객체의 내부슬롯 [[Environment]]에 저장한다.

### 23.6.5 foo 함수 코드 실행
- 매개변수엔 인수가 할당되고 함수가 호출된다. 이때 식별자 결정을 위해 렉시컬 환경에서 식별자를 검색하기 시작한다.
- 함수 환경 내에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조를 따라 식별자를 검색하여 일치하는 것이 있으면 할당한다.

### 23.6.6 bar 함수 코드 평가
- 내부 함수가 호출되면 다시 내부 함수로 코드 제어권이 이동한다. 마찬가지로 내부 함수의 평가와 실행이 이뤄진다. 

### 23.6.7 bar 함수 코드 실행
- 메서드 실행 시 식별자를 스코프체인에서 마찬가지로 검색하며, 없다면 스코프체인을 타고 올라가 찾는다. 
- console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.

### 23.6.8 bar 함수 코드 실행 종료
- 내부 함수의 실행 컨텍스트 스택이 팝되고 외부함수의 실행컨텍스트가 다시 스택에서 최상위 포지션이 된다.
- 내부 함수의 실행이 종료되었다고 해서 내부 함수 bar의 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 실행 컨텍스트에 의해 참조되지만 독립적인 객체이어서, 누군가 참조하고 있다면 bar 렉시컬 환경은 소멸되지 않는다.(클로저)

### 23.6.9 foo 함수 코드 실행 종료
- 외부함수도 종료되고 실행컨텍스트 스택에서 빠진다.
- 다시 전역 실행 컨텍스트가 실행중인 실행 컨텍스트가 된다.

### 23.6.10 전역 코드 실행 종료
- 끝까지 코드를 실행하고 전역 실행 컨텍스트도 팝되어 사라진다.
- 최종적으로, 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다.

## 23-7. 실행 컨텍스트와 블록 레벨 스코프
- var 키워드 선언한 변수는 함수 코드 블록만 지역 스코프로 인정한다.
- 하지만 let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정한다. (블록 레벨 스코프)
- if문(내부에 let 키워드로 선언된 변수가 있다면)과 같은 블록이 생성되면 새로운 렉시컬 환경을 생성한다.
- for문에서 let을 사용하였다면 코드블록이 반복실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다. 
  - for문 상위에 있는 스코프가 식별자를 유지하게끔 독립적인 렉시컬 환경을 생성한다.