# 16장 프로퍼티 어트리뷰트

## 16-1. 내부 슬롯과 내부 메서드
- 내부 슬롯 & 내부 메서드 : 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 슈도 프로퍼티, 메서드
- 이중 대괄호로 감싼 이름들
- 직접 내부 슬롯과 내부 메서드에 접근하거나 호출할 수 없음
- 그러나, 일부는 제공한다.
  - [[Prototype]] => `__proto__`를 통해 간접적으로 접근한다.

## 16-2. 프로퍼티 어트리뷰트와 프로퍼티 디스크럽터 객체
- 프로퍼티를 생성할 때, 자바스크립트 엔진은 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
- 프로퍼티 어트리뷰트 : 프로퍼티의 값, 갱신가능여부, 열거가능여부, 재정의 가능 여부
- Object.getOwnPropertyDescriptor 메서드
  - 첫번째 매개변수 -> 객체, 두번째 매개변수 -> 프로퍼티 키
  - 프로퍼티 디스크럽터 객체를 반환한다.
- Object.getOwnPropertyDescriptors 메서드 (ES8에서 도입)
  - 프로퍼티의 모든 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체를 반환

## 16-3. 데이터 프로퍼티와 접근자 프로퍼티 
- 데이터 프로퍼티 : 키 와 값 으로 이뤄진 일반적인 프로퍼티
- 접근자 프로퍼티 : 자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출하는 접근자 함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티
- [[Value]]
  - 프로퍼티 키를 통해 접근하면 반환되는 값
  - 프로퍼티 키를 통해 프로퍼티 값을 변경하면 값을 재할당한다. 프로퍼티가 없으면 프로퍼티를 동적 생성하고 값을 저장한다.
- [[Writable]]
  - false 인 경우 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.
- [[Enumerable]]
  - false인 경우 for...in문이나 Object.keys 메서드 등으로 열거할 수 없다.
- [[Configurable]]
  - false인 경우 해당 프로퍼티의 삭제나 프로퍼티 어트리뷰트 값의 변경이 금지 된다.
  - 단, Writable이 true 인 경우 Value 변경이나 Writable을 false로 바꿀 수 있다.

### 16.3.2 접근자 프로퍼티
- [[Get]] : getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.
- [[Set]] : setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.
- [[Enumerable]]
- [[Configurable]]
- getter/setter 함수라고도 부른다. getter와 setter 모두 정의할 수도 있고, 하나만 정의할 수도 있다. 

> js에도 getter/setter가 있는지 처음 알았다.

#### [[Get]] 내부 메서드 동작 프로세스
  1. 프로퍼티 키가 유효한지 확인
  2. 프로토타입 체인에서 프로퍼티 검색
  3. 데이터 프로퍼티인지 접근자 프로퍼티인지 확인
  4. [[Get]]의 값, getter를 호출하여 그 결과를 반환한다. 

- 일반 객체의 `__proto__`는 접근자 프로퍼티이다.
- 함수 객체의 prototype은 데이터 프로퍼티다. 

## 16-4. 프로퍼티 정의
- Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다.
- {
  value: '',
  writable: true,
  enumerable: true,
  configurable: true,
}
- 정의단계에서 누락하면, 기본값이 자동으로 지정됨
- value, get, set => undefined
- writable, enumerable, configurable => false
- Object.defineProperties 메서드를 사용하면 한번에 여러 프로퍼티를 정의할 수 있다.

## 16-5. 객체 변경 방지
- 자바스크립트에서는 객체를 재할당 없이 변경할 수 있다. 
- 그래서 객체의 변경을 방지하는 다양한 메서드들을 제공한다. 

### 16.5.1 객체 확장 금지
- Object.preventExtensions 메서드는 프로퍼티 추가를 금지한다.
- 프로퍼티 추가는 프로퍼티 동적 추가와 Object.defineProperty 메서드로 추가할 수 있다.
- 프로퍼티 삭제는 가능하다.
- 확인 메서드 : isExtensible()

### 16.5.2 객체 밀봉
- Object.seal 메서드는 객체를 밀봉한다.
- 밀봉된 객체는 읽기와 쓰기만 가능하다.
- 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지를 의미한다.
- 확인 메서드 : isSealed()

### 16.5.3 객체 동결
- Object.freeze 메서드는 객체를 동결한다.
- 동결된 객체는 읽기만 가능하다.
- 확인 메서드 : isFrozen()

### 16.5.4 불변 객체
- 앞선 메서드들은 직속 프로퍼티만 변경이 방지되고, 중첩 객체까지는 영향을 주지 못한다.
- 불변 객체를 구현하려면 재귀적으로 Object.freeze를 호출해야한다.

```js
function deepFreeze(target) {
  if (target && typeof target === 'Object' && !Object.isFrozen(target)) {
    Object.freeze(target);
    Object.keys(target).forEach(key => deepFreeze(target[key]));
  }
  return target;
}
```

# 17장 생성자 함수에 의한 객체 생성

## 17-1. Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.

## 17-2. 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성방식의 문제점
- 객체 리터럴에 의한 생성은 직관적이고 간편하다.
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야하는 경우에는 매번 프로퍼티를 기술해야함으로 비효율적이다.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점
- 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

### 17.2.3 생성자 함수의 인스턴스 생성 과정
- 생성자 함수의 역할
  - 인스턴스 생성
  - 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가, 초기값 할당)

#### 1. 인스턴스 생성과 this 바인딩
- 암묵적으로 빈 객체가 생성되고 인스턴스는 this에 바인딩 된다.
- 이 단계는 런타임 이전에 실행된다. 

#### 2. 인스턴스 초기화
- this에 바인딩 되어있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기 값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.

#### 3.인스턴스 반환
- 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.
- return문에 다른 객체를 명시적으로 반환한다면 그 객체가 반환된다.
- 원시값을 명식적으로 반환하려고하면 무시되고 this가 반환된다.

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]
- 함수는 객체 이므로 일반 객체와 동일하게 동작할 수 있다.
- 그러나, 함수만이 갖고 있는 내부슬롯과 내부 메서드가 있다. 
- 함수가 호출되면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 호출되면 내부 메서드 [[Construct]]가 호출된다.
- 모든 함수 객체는 [[Call]]을 갖고 있는 callable이나 모두가 [[Construct]]를 갖고 있는 것은 아니다.

### 17.2.5 constructor와 non-constructor의 구분
- 함수 정의 방식에 따라 constructor와 non-constructor를 구분한다. 
- non-constructor 함수 객체를 생성자 함수처럼 호출하면 에러가 발생한다.
- 생성자함수로서 정의하지 않은 일반함수도 생성자 함수처럼 동작할 수 있다.

### 17.2.6 new 연산자
- new를 통해 함수를 호출하면 생성자 함수로 동작한다.
- 내부메서드 [[Construct]]가 호출된다. new 연산자와 호출되는 함수는 constructor이어야 한다.

### 17.2.7 new.target
- 메타 프로퍼티
- 함수 내부에서 사용 시 생성자 함수로서 호출되었는지 확인할 수 있다. 
- 생성자 함수로 호출 시 => 함수 자신
- 일반 함수로 호출시 => undefined

# 18장 함수와 일급 객체

## 18-1. 일급 객체
- 일급 객체
  - 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
    > 런타임에 생성하기 때문에 무명 리터럴로 생성할 수 있는 것
  - 변수나 자료구조에 저장할 수 있다.
  - 함수의 매개변수에 전달할 수 있다. 
  - 함수의 반환값으로 사용할 수 있다.
- 자바스크립트의 함수는 위의 모든 조건을 만족하기에, 일급 객체이다.
  - 객체와 동일하게 사용할 수 있으며, 매개변수에 전달할 수 있다. 반환값으로도 사용될 수 있다.
  - 값을 사용할 수 있는 곳이라면 어디서든 리터럴로 정의할 수 있으며, 런타임에 함수 객체로 평가된다.
  - 일반객체에는 없는 고유의 프로퍼티를 함수는 갖고 있다.
  - 함수 객체는 호출할 수 있다. 

## 18-2. 함수 객체의 프로퍼티

### 18.2.1 arguments 프로퍼티
- 값은 arguments 객체다.
  - 함수 호출시 전달된 인수들의 정보를 담고있는 이터러블한 유사배열 객체이다.
  - 함수 내에서 지역 변수처럼 사용된다.
- ES3부터 표준에서 폐지되었다.
- 자바스크립트 엔진이 함수의 매개변수와 인수의 개수가 일치하는지 확인하지는 않는다. 
  - 인수보다 적게 전달되는 경우 undefined로 초기환된 상태를 유지한다.
  - 많이 전달된 경우 나머지는 무시되고 arguments 프로퍼티에 보관된다.
- 매개변수의 개수를 확정할 수 없는 함수로직을 구현할 때 유용하다.

```js
const test = (...args) => {
  if (args.length === 0) {
    return 0;  
  } else if (args.length === 1) {
    return 1;  
  } else if (args.length === 2) {
    return 2;  
  } else {
    return -1;  
  }
};
```

- ES6 이후 ...args와 같은 Rest 파라미터 도입으로 잘 쓰이지 않고 있다.

### 18.2.2 caller 프로퍼티
- ECMA script 사양에는 없는 비표준 프로퍼티
- 함수 자신을 호출한 함수를 가리킴

### 18.2.3 length 프로퍼티
- 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.
- arguments 객체의 length 프로퍼티는 인자의 개수를 가리킨다. 함수객체의 length 프로퍼티와는 다를 수 있다.

### 18.2.4 name 프로퍼티
- 함수 이름을 나타낸다. 
- 익명 함수 표현식의 경우 
  - ES5에서는 빈문자열을 값으로 갖는다.
  - ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.
 
### 18.2.5 `__proto__` 접근자 프로퍼티
- [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체

### 18.2.6 prototype 프로퍼티
- constructor만 갖는 프로퍼티이다. 
- 생성자 함수가 생성할 인스턴스의 프로토타입을 객체를 가리킨다.

# 19장 프로토타입

- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.
- ES6에서 클래스가 도입되었으나 새로운 객체 지향 모델을 제공한다기 보다는 새로운 객체 생성 메커니즘이라고 보는 게 적합하다.
- 원시값을 제외한 모든 값들은 모두 객체이다.

## 19-1. 객체지향 프로그래밍
- 객체 지향 프로그래밍 : 프로그램을 객체의 집합으로 표현하는 프로그래밍 패러다임
- 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작
- 실체는 속성을 갖고 있고, 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것을 **추상화** 라고 함.
- 객체
  - 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
  - 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조
  - 상태 데이터 => **프로퍼티**
  - 동작 => **메서드** 

## 19-2. 상속과 프로토타입
- 상속 : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
- 상속을 통해 기존 코드를 재사용하여 불필요한 중복을 제거할 수 있다.
- 자바스크립트는 prototype을 통해 상속을 구현할 수 있다.

## 19-3. 프로토타입 객체

- 프로토타입 객체 : 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다.
- 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬록의 값은 프로토타입의 참조이다.
- 모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어있다.
- 생성자 함수 <- 생성자함수.prototype <- 객체

### 19.3.1 `__proto__` 접근자 프로퍼티

#### 1. `__proto__`는 접근자 프로퍼티다. 
- 모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다. 
- 접근자 프로퍼티 : (p.223 참고)
- `__proto__`를 통해 [[Prototype]]에 접근하여 내부 슬롯의 값을 취득하거나 할당한다.

#### 2. `__proto__` 접근자 프로퍼티는 상속을 통해 사용된다.
- `__proto__`는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다.
- 모든 객체가 상속을 통해 Object.prototype.`__proto__` 접근자 프로퍼티를 사용할 수 있다. 
- 모든 객체는 프로토타입 체인에 묶여있다. 프로토타입 체인의 종점에는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에 상속된다.
- 자바스크립트 엔진은 객체의 프로퍼티, 메서드에 접근할 때, 해당 객체에 그 프로퍼티나 메서드가 없다면 `__proto__` 접근자 프로퍼티가 가리키는 참조를 따라올라가 부모의 프로토타입 프로퍼티에서 찾는다.

#### 3. `__proto__` 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유
- 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서이다.
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 프로퍼티 검색방향이 한쪽방향으로 흘러가야하기 때문이다.
- 비정상적인 프로토타입 체인, 순환 참조하는 프로토타입 체인은 프로토타입 체인이 종점이 존재하지 않아 무한루프에 빠진다. 그래서 무조건적인 프로토타입을 교체를 방지하기 위해 `__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어있다. (미리 에러를 일으킴)

#### 4. `__proto__` 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않음
- ES6에서부터 `__proto__`를 표준으로 채택했다.
- 그러나 이를 코드 내에서 사용하는 것은 권장하지 않는다. 그 이유는 모든 객체가 `__proto__` 를 사용할 수 있는 것이 아니기 때문이다.
- **Object.getPrototypeOf** 메서드 : 프로토타입의 참조를 취득하고 싶은 경우의 대안
- **Object.setPrototypeOf** 메서드 : 프로토타입을 교체하고 싶은 경우의 대안

### 19.3.2 함수 객체의 prototype 프로퍼티
- 함수 객체만이 갖고 있는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
- prototype 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다.
- non-constructor 함수는 소유하지 않는다.(화살표함수, ES6 메서드 축약표현으로 정의된 메서드)
- 생성자 함수로 호출하기 위해 정의되지 않은 일반함수도 prototype 프로토타입을 갖고 있으나, 아무런 의미가 없다. 
- 모든 객체가 갖고있는 (Object.prototype으로부터 상속 받은) `__proto__` 접근자 프로퍼티와 함수 객체만이 갖고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.

  > 생성자 함수.prototype **=>** prototype **<=** 인스턴스.`__proto__` 
- 그러나 사용주체가 `__proto__`는 _모든 객체_, prototype 프로퍼티는 _생성자 함수_ 로 다르다.


### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수
- 모든 프로토타입은 constructor 프로퍼티를 갖는다. 
- constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
- 이 연결은 생성자 함수가 생성될 때 형성된다.

## 19-4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
- 리터럴 표기법에 의해 생성된 객체의 프로토타입의 constructor 프로퍼티는 반드시 객체를 생성한 생성자 함수라 단언할 수 없다.
- 리터럴로 객체를 생성하면 constructor가 `Object`로 나온다
  - 실제로 Object 생성자함수로 생성되는 것은 아니다. 
  - 추상연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점은 Object생성자 함수 호출과 객체 리터럴 동일하다.
  - 그러나 new.target 확인, 프로퍼티 추가 처리 등의 세부 내용에 차이가 있다.
  - 리터럴에 의해 생성한 객체도 상속을 위해 프로토타입이 필요하므로, 가상의 생성자 함수를 배정받는다.(Object, Function, Array, RegExp)
  => **프로토타입과 생성자 함수는 단독으로 존재할 수 없고, 언제나 쌍으로 존재한다.**
  - 결론적으로, 리터럴 객체를 생성한 생성자 함수를 'Object'로 생각해도 크게 무리는 없다.

## 19-5. 프로토타입의 생성 시점
- 결국, 모든 객체는 생성자 함수와 연결되어있다. 
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점
- 생성자 함수로서 호출할 수 있는 함수 Constructor는 함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
- non-constructor는 프로토타입이 생성되지 않는다.
- 프로토타입도 객체고, 모든 객체는 프로토타입을 가지므로, 프로토타입도 자신의 프로토타입을 갖는다.
- 생성된 프로토타입의 프로토타입은 Object.prototype

### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점
- Object, String, Number, Function, Array, RegExp, Date, Promise와 같은 빌트인 생성자 함수도 생성 시점에 프로토타입이 생성된다.
- 생성 시점 : 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.

> <전역객체> <br/>
> - 브라우저에서는 window, Node.js에서는 global <br/>
> - 프로퍼티 : 표준 빌트인 객체, 호스트 객체, 전역 변수(var 키워드로 선언)와 전역 함수

- 객체가 생성되기 전부터 생성자 함수와 프로토타입은 이미 객체화되어 존재한다.
- 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.

## 19-6. 객체 생성 방식과 프로토타입의 결정
- 모든 객체 생성 방식은 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다. 
- 프로토타입은 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다.
- 이 인수는 객체 생성 시점에 객체 생성 방식에 의해 결정된다.

### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입
- 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.
- Object.prototype를 상속받는다. 

### 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입
- Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.
- 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는다.

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입
- new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성한 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체이다. 
- 사용자 정의 생성자 함수에서 정의된 메서드와 constructor만 상속받는다. 

## 19-7. 프로토타입 체인
- 그러나, Object.prototype의 메서드인 hasOwnProperty를 호출할 수 있다. 
- 이는 사용자 정의 생성자 함수의 프로토타입뿐만 아니라 Object.prototype도 상속받았다는 얘기이다.
- 생성자함수.prototype의 프로토타입은 Object.prototype이다. 
- 프로토타입의 프로토타입은 언제나 Object.prototype이다.

### <프로토타입 체인>
> 자바스크립트는 객체의 프로퍼티, 메서드에 접근하고자 할 때 해당 객체에 접근하려는 프로퍼티,메서드가 없다면 [[Prototype]] 참조를 따라 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 

- 프로토타입 체인의 최상위 객체는 언제나 Object.prototype이다.
- 프로토타입 체인의 종점 (end of prototype chain)
- 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다. 
  - 스코프 체인은 식별자 검색을 위한 메커니즘이다.
  - 이 둘은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다.

## 19-8. 오버라이딩과 프로퍼티 섀도잉
- 인스턴스가 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 추가하면, 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다.
- 프로퍼티 섀도잉 : 상속 관계에 의해 프로퍼티가 가려지는 현상 (인스턴스 프로퍼티가 프로토타입 프로퍼티를 가림)
- 삭제의 경우에도 프로퍼티 섀도잉 현상이 일어난다. 그래서 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. get 액세스는 허용하나 set 액세스는 허용되지 않는다.

## 19-9. 프로토타입의 교체
- 프로토타입을 임의의 다른 객체로 변경할 수 있다. 그러므로 객체 간의 상속 관계 또한 동적으로 변경될 수 있다.

### 19.9.1 생성자 함수에 의한 프로토타입의 교체
- 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체할 수 있다.
- 이 경우 인스턴스의 constructor가 Object가 된다.

### 19.9.2 인스턴스에 의한 프로토타입의 교체
- 인스턴스의 `__proto__` 접근자 프로퍼티로도 프로토타입을 교체할 수 있다.
- 앞선 교체와의 차이는 미래의 인스턴스의 프로토타입을 교체했다면, 이번 교체는 이미 생성된 프로토타입을 교체하는 것이다.
- 마찬가지로 생성자 함수와 프로토타입 간 연결이 파괴되어 constructor가 없어져, Object가 constructor로 나온다.

> 생성자 함수에 의한 교체와 인스턴스에 의한 교체의 차이 <br/>
> => 후자의 경우 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리키지 않는다. 

- 이러한 교체는 번거롭기에, ES6에 도입된 클래스를 통해 상속 관계를 직접 구현하는 편이 낫다.

## 19-10. instanceof 연산자
- 우변의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재하면 true를 반환한다. 
- 실제로 좌변과 우변이 생성자 - 인스턴스 관계인 것은 무관하다.
- constructor로 연결되어있지 않아도 true를 반환할 수 있다.

## 19-11. 직접 상속

### 19.11.1 Object.create에 의한 직접 상속
- 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. 
- 첫번째 매개변수에는 객체의 프로토타입으로 지정할 객체를 전달
- 두번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크럽터 객체로 이뤄진 객체를 전달한다. (옵션)
- 객체를 생성하면서 직접 첫번째 매개변수의 객체를 프로토타입으로 생성하며 직접 상속을 구현한다.
- 매개변수에 null을 넣으면 프로토타입 체인 종점에 위치하는 객체를 생성할 수 있다. 
  - 이로 인해 빌트인 메서드는 Object.prototype.hasOwnProperty.call~ 과 같이 호출하는것을 권장한다.

### 19.11.2 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속
- ES6에서는 접근자 프로퍼티를 통해 직접 상속을 구현할 수 있다.

## 19-12. 정적 프로퍼티 / 메서드
- 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티 메서드
- 인스턴스가 참조/호출할 수 없다.(프로토타입 체인에 속해있지 않기 때문)
- 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않는다면, 정적 메서드로 변경시킬 수 있다.

## 19-13. 프로퍼티 존재 확인

### 19.13.1 in 연산자
- key in object
- 객체 내 특정 프로퍼티 존재 여부를 확인한다. 
- 그러나, 해당 객체 상속 받은 모든 프로토타입의 프로퍼티를 확인하므로 주의해야한다. 

### 19.13.2 Object.prototype.hasOwnProperty 메서드
- 특정 프로퍼티가 존재하는지 확인하는데 사용할 수 있다. 
- in 연산자와 다르게, 고유의 프로퍼티 키인 경우만 찾고 싶을 때 사용하는 메서드이다. 

## 19-14. 프로퍼티 열거

### 19.14.1 for...in 문
- for (변수 선언문 in 객체 ) {...}
- 객체의 모든 프로퍼티를 순회하면 열거할때 사용한다.
- 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 값만 열거한다.
- Object.prototype의 프로퍼티는 false이기에 열거되지 않는다.
- key가 심벌인 프로퍼티인 경우에도 열거되지 않는다.
- 자신의 프로퍼티만 열거하려면 hasOwnProperty와 함께 사용하여 확인해야한다.
- for...in 문은 순서를 보장하지 않지만, 대부분의 모던 브라우저들은 순서를 보장하고 있고 숫자인 프로퍼티 키에 대해서는 정렬을 실시한다.

### 19.14.2 Object.keys/values/entries 메서드
- 객체 고유 프로퍼티만 열거하기 위함이라면 Object.keys/values/entries 메서드를 권장한다. 

#### Object.keys
- 프로퍼티 키를 배열로 반환

#### Object.values
- 프로퍼티 값을 배열로 반환

#### Object.entries
- 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환